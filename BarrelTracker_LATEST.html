
<!DOCTYPE html>
<!-- saved from url=(0038)https://mrimp.github.io/BarrelTracker/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BarrelTracker â€” v4.5.24</title>
<script>
  // Single source of truth for displayed tool version
  window.BT_APP = { name: "BarrelTracker", version: "4.5.24", channel: "release", build: "2026-01-05", debug: false };
  document.title = `${window.BT_APP.name} â€” v${window.BT_APP.version}`;
  // Release build stamp
  window.BT_APP.tag = `v${window.BT_APP.version}` + (window.BT_APP.build ? ` (${window.BT_APP.build})` : "");
</script>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0f17;
    --panel:#0f172a;
    --panel2:#0b1227;
    --row:#0f172a;
    --row-alt:#0c1324;
    --text:#d9e2ee;
    --muted:#8ea0b6;
    --hi:#22c55e;
    --mod:#f59e0b;
    --low:#64748b;
    --bad:#ef4444;
    --border:#1f2937;
    --accent:#1d4ed8;
    --accent2:#2563eb;
    --shadow:0 20px 70px rgba(0,0,0,.45);
    --radius:18px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:radial-gradient(900px 500px at 20% 0%, rgba(99,102,241,.25), transparent 60%),
               radial-gradient(700px 500px at 80% 10%, rgba(34,197,94,.12), transparent 60%),
               linear-gradient(180deg,#070a12,#020617);
    color:var(--text);
  }


  /* ---- Suite unified header (NodeLab-style) ---- */
  .suiteHeader{
    display:flex; align-items:center; justify-content:space-between;
    gap:16px;
    padding:10px 16px;
    border-radius:28px;
    border:1px solid rgba(255,255,255,.10);
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    background: linear-gradient(135deg, rgba(34,42,55,.55), rgba(25,33,40,.45));
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    margin: 0 0 18px;
  }
  .suiteHeader__topline{ display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
  .suiteHeader__title{ font-size:30px; font-weight:760; letter-spacing:.2px; line-height:1.05; }
  .suiteHeader__pill{
    font-size:13px; padding:3px 9px; border-radius:999px;
    border:1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.16);
    color: var(--muted);
  }
  .suiteHeader__pill--muted{ opacity:.85; }
  .suiteHeader__tagline{ margin-top:6px; color:var(--muted); font-size:16px; line-height:1.25; max-width: 900px; }
  .suiteHeader__right{ display:flex; align-items:center; gap:14px; }
  .suiteHeader__actions{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
  .suiteHeader__badge{
    width:54px; height:54px; border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    background: radial-gradient(circle at 30% 30%, rgba(223,230,236,.12), rgba(0,0,0,.20));
    box-shadow:0 10px 22px rgba(0,0,0,.35);
    overflow:hidden;
    display:flex; align-items:center; justify-content:center;
    flex: 0 0 auto;
  }
  .suiteHeader__badgeImg{ width:100%; height:100%; object-fit:cover; display:block; }

  @media (max-width: 920px){
    .suiteHeader{ align-items:flex-start; }
    .suiteHeader__right{ flex-direction:column-reverse; align-items:flex-end; gap:10px; }
    .suiteHeader__tagline{ font-size:16px; }
    .suiteHeader__title{ font-size:30px; }
  }
  @media (max-width: 520px){
    .suiteHeader{ padding:12px 14px; border-radius:22px; }
    .suiteHeader__title{ font-size:26px; }
    .suiteHeader__badge{ width:56px; height:56px; }
  }
  /* Hide legacy header styles (replaced) */
  .wrap{
    max-width:1240px;
    margin:0 auto;
    padding:28px 18px 70px;
  }
  .title{
    display:flex; gap:12px; align-items:center;
  }
  .logo{
    width:40px; height:40px; border-radius:14px;
    background-image:url('data:image/jpeg;base64,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');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(255,255,255,.08);
    box-shadow:0 12px 30px rgba(0,0,0,.35);
  }
  h1{
    font-size:22px;
    margin:0;
    letter-spacing:.2px;
  }
  .subtitle{
    margin-top:6px;
    font-size:13px;
    color:var(--muted);
  }

  .pillrow{
    display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
  }
  .pill{
    background:rgba(2,6,23,.55);
    border:1px solid rgba(255,255,255,.08);
    border-radius:999px;
    padding:7px 10px;
    color:#b6c3f2;
    font-size:12px;
    backdrop-filter: blur(8px);
  }
  .btn{
    border:1px solid rgba(255,255,255,.10);
    background:rgba(2,6,23,.35);
    color:var(--text);
    padding:9px 12px;
    border-radius:12px;
    font-weight:600;
    font-size:13px;
    cursor:pointer;
  }
  .btn.primary{
    background:linear-gradient(180deg, var(--accent2), var(--accent));
    border-color:rgba(29,78,216,.65);
    box-shadow:0 14px 35px rgba(29,78,216,.25);
  }

  .btn.danger{
    background:linear-gradient(180deg, rgba(239,68,68,.35), rgba(239,68,68,.16));
    border-color:rgba(239,68,68,.55);
    box-shadow:0 14px 35px rgba(239,68,68,.18);
  }
  .btn.danger:hover{
    background:linear-gradient(180deg, rgba(239,68,68,.42), rgba(239,68,68,.20));
  }
  .btn:active{transform:translateY(1px)}

  .btn.sm{
    padding:7px 10px;
    border-radius:10px;
    font-weight:700;
    font-size:12px;
  }

  .panel{
    background:radial-gradient(1200px 360px at top left, rgba(30,27,75,.80), transparent 65%),
               rgba(2,6,23,.55);
    border:1px solid rgba(255,255,255,.08);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }

  .panelHead{
    padding:16px 18px 12px;
    border-bottom:1px solid rgba(255,255,255,.08);
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap:16px;
  }
  .panelHead h2{
    margin:0;
    font-size:16px;
    letter-spacing:.2px;
  }
  .panelHead .note{
    font-size:12px;
    color:var(--muted);
    margin-top:6px;
  }
  .controls{
    display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    align-items:center;
  }
  .select{
    background:rgba(2,6,23,.45);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 10px;
    color:var(--text);
    font-size:13px;
  }

  /* Dark dropdown menus (options list) */
  .select option, .select optgroup{
    background: #0b1227;
    color: var(--text);
  }
  .select:disabled{
    opacity:.6;
    cursor:not-allowed;
  }
.input{
    background:rgba(2,6,23,.45);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 12px;
    color:var(--text);
    font-size:13px;
    outline:none;
  }
  .input::placeholder{ color: rgba(142,160,182,.85); }
  .input:focus{
    border-color: rgba(37,99,235,.55);
    box-shadow: 0 0 0 3px rgba(37,99,235,.18);
  }

  .toggle{
    display:flex; gap:8px; align-items:center;
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(2,6,23,.35);
    color:var(--text);
    font-size:13px;
    user-select:none;
  }
  .toggle input{accent-color:var(--accent2)}
  .hint{
    padding:10px 18px 0;
    font-size:12px;
    color:var(--muted);
  }
  .helpIcon{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:18px; height:18px;
    margin-left:8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(2,6,23,.35);
    color:#b6c3f2;
    font-size:12px;
    font-weight:900;
    cursor:help;
    user-select:none;
  }
  .helpIcon:hover{background:rgba(2,6,23,.55)}

  table{
    width:100%;
    border-collapse:collapse;
    font-size:14px;
  }
  thead th{
    text-align:left;
    font-weight:700;
    color:#b6c3f2;
    padding:10px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
    white-space:nowrap;
  }
  tbody tr{
    background:rgba(15,23,42,.55);
    cursor:pointer;
  }
  tbody tr:nth-child(even){
    background:rgba(12,19,36,.55);
  }
  tbody tr:hover{
    background:rgba(17,28,54,.75);
  }
  td{
    padding:12px 10px;
    border-bottom:1px solid rgba(255,255,255,.06);
    white-space:nowrap;
  }
  .ranknum{font-weight:900}
  .barrel{font-weight:800}
  .score{font-weight:900}
  .muted{color:var(--muted)}
  .conf{font-weight:800}
  .conf.high{color:var(--hi)}
  .conf.mod{color:var(--mod)}
  .conf.low{color:var(--low)}
  .trend.up{color:var(--hi)}
  .trend.flat{color:var(--mod)}
  .trend.down{color:var(--bad)}
  .empty{opacity:.45; cursor:default}
  .empty:hover{background:inherit}

  /* subtle row glow by confidence */
  tr.glow-high { box-shadow: inset 0 0 0 1px rgba(34,197,94,.28), 0 0 0 1px rgba(34,197,94,.10), 0 0 22px rgba(34,197,94,.08); }
  tr.glow-mod  { box-shadow: inset 0 0 0 1px rgba(245,158,11,.26), 0 0 0 1px rgba(245,158,11,.10), 0 0 22px rgba(245,158,11,.08); }
  tr.glow-low  { box-shadow: inset 0 0 0 1px rgba(100,116,139,.22), 0 0 0 1px rgba(100,116,139,.08), 0 0 18px rgba(100,116,139,.06); }

  .spark{
    width:78px; height:18px; display:inline-block; vertical-align:middle; opacity:.9;
  }
  .spark path{
    fill:none; stroke:currentColor; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;
  }
  .spark .dot{fill:currentColor}
  .trendwrap{display:flex; align-items:center; gap:10px}
  .trendwrap .arrow{min-width:18px; text-align:center; font-weight:900}

  /* v4.3-style trend cell (inline icon + spark) */
  .trendMini{
    border:0;
    background:transparent;
    padding:0;
    margin:0;
    color:inherit;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
  }
  .trendMini:focus{ outline: 2px solid rgba(148,163,184,.45); outline-offset: 2px; border-radius:10px; }

  /* detail drawer */
  .drawer{
    margin-top:18px;
    display:grid;
    grid-template-columns: 1fr;
    gap:16px;
  }
  @media (max-width: 980px){
    .drawer{grid-template-columns:1fr}
  }
  .card{
    background:radial-gradient(900px 240px at top left, rgba(30,27,75,.65), transparent 65%),
               rgba(2,6,23,.55);
    border:1px solid rgba(255,255,255,.08);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .cardHead{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.08);
    display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
  }
  .cardHead h3{
    margin:0; font-size:15px;
  }
  .cardHead .small{
    margin-top:6px; font-size:12px; color:var(--muted);
  }
  .cardBody{padding:14px 16px}
  .sessionRow{
    padding:12px 12px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(2,6,23,.35);
    border-radius:14px;
    margin-bottom:10px;
  }
  .sessionTitle{
    font-weight:800;
    letter-spacing:.15px;
  }
  .chips{display:flex; gap:8px; margin-top:6px; flex-wrap:wrap}
  .chip{
    display:inline-flex; align-items:center;
    padding:5px 9px;
    border-radius:999px;
    font-size:12px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(2,6,23,.45);
    color:#b6c3f2;
  }
  .chip.sighters{color:#e5e7eb}
  .fileLine{margin-top:6px; font-size:12px; color:var(--muted)}
  .kpis{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:10px;
    margin-bottom:12px;
  }
  .kpi{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(2,6,23,.35);
  }
  .kpi .lbl{font-size:12px; color:var(--muted)}
  .kpi .val{font-size:16px; font-weight:900; margin-top:4px}
  .mini{
    font-size:12px; color:var(--muted); line-height:1.4;
  }
  .footerNote{
    margin-top:14px;
    font-size:12px;
    color:var(--muted);
    text-align:center;
  }
  .badgeDemo{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(245,158,11,.25);
    background:rgba(245,158,11,.10);
    color:#fde68a;
    font-size:12px;
    font-weight:700;
  }
  .pop{
    position:absolute;
    right:18px;
    top:72px;
    width:320px;
    z-index:50;
    background:radial-gradient(700px 220px at top left, rgba(30,27,75,.70), transparent 65%), rgba(2,6,23,.92);
    border:1px solid rgba(255,255,255,.12);
    border-radius:16px;
    box-shadow:0 30px 80px rgba(0,0,0,.55);
    backdrop-filter: blur(10px);
  }
  .popHead{padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); font-weight:900}
  .popBody{padding:12px 14px}
  .popRow{display:grid; grid-template-columns: 120px 1fr; gap:10px; align-items:center; margin-bottom:10px}
  .popLbl{font-size:12px; color:var(--muted); font-weight:700}
  .popActions{display:flex; gap:8px; justify-content:flex-end; margin-top:8px}
  .tileGrid{display:grid; grid-template-columns:1fr; gap:10px}
  .tile{
    padding:12px 12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(2,6,23,.35);
    cursor:pointer;
  }
  .tile:hover{background:rgba(2,6,23,.45)}
  .tile .tTitle{font-weight:900}
  .tile .tSub{margin-top:6px; font-size:12px; color:var(--muted); line-height:1.35}
  .tile.disabled{opacity:.55; cursor:not-allowed}

  .impGrid{display:grid;grid-template-columns:1fr;gap:12px}
  .drop{
    border:1px dashed rgba(255,255,255,.18);
    background:rgba(2,6,23,.28);
    border-radius:16px;
    padding:12px 12px;
  }
  .drop.drag{border-color:rgba(99,102,241,.55); background:rgba(99,102,241,.10)}
  .dropTop{display:flex;justify-content:space-between;align-items:center;gap:10px}
  .dropTitle{font-weight:800}
  .dropSub{font-size:12px;color:var(--muted);margin-top:4px}
  .fileList{margin-top:10px;display:flex;flex-direction:column;gap:8px}
  .fileItem{padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(2,6,23,.25)}
  .fileItem .nm{font-weight:700}
  .fileItem .sm{font-size:12px;color:var(--muted);margin-top:4px;line-height:1.3}
  .pairTbl{width:100%;border-collapse:separate;border-spacing:0 8px;margin-top:10px}
  .pairTbl td{border:0;padding:0}
  .pairRow{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .pairCard{padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(2,6,23,.25)}
  .pairCard .top{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
  .pairCard .nm{font-weight:800}
  .pairCard .meta{font-size:12px;color:var(--muted);margin-top:4px}
  .pairCard select{width:100%;margin-top:8px}
  .impActions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;margin-top:10px}
  .warnBox{margin-top:10px;padding:10px 10px;border-radius:14px;border:1px solid rgba(245,158,11,.25);background:rgba(245,158,11,.08);color:#fde68a;font-size:12px;line-height:1.35}

  body[data-mode="import"] #selWindow{display:none!important;}


  /* Session Edit Modal */
  body.modalOpen{overflow:hidden!important;}

  .modalOverlay{
    position:fixed; inset:0;
    background:rgba(2,6,23,.72);
    backdrop-filter: blur(6px);
    display:none;
    align-items:flex-start;
    justify-content:center;
    padding:40px 14px;
    overflow:auto;
    overscroll-behavior:contain;
    z-index:9999;
  }
  .modalCard{
    width:min(860px, 96vw);
    border:1px solid rgba(255,255,255,.10);
    background:rgba(15,23,42,.92);
    border-radius:18px;
    box-shadow:0 18px 55px rgba(0,0,0,.45);
    overflow:hidden;
    max-height: calc(100vh - 80px);
    display:flex;
    flex-direction:column;
  }
  .modalHead{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.10);
    display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
  }
  .modalHead h3{margin:0;font-size:15px}
  .modalBody{padding:14px 16px; overflow:auto; flex:1}
  .modalFoot{
    padding:14px 16px;
    border-top:1px solid rgba(255,255,255,.10);
    display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center;
  }
  .iconBtn{
    border:1px solid rgba(255,255,255,.12);
    background:rgba(2,6,23,.35);
    color:var(--text);
    border-radius:12px;
    padding:6px 10px;
    cursor:pointer;
    font-size:12px;
  }
  .iconBtn:hover{background:rgba(2,6,23,.55)}
  .sessionRow .rowTop{
    display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
  }
  .sessionRow{cursor:pointer}
  .sessionRow:active{transform: translateY(0.5px)}


/* "Last session" compact cell (no reflow) */
th.lastCol, td.lastCol{ max-width:160px; width:160px; }
td.lastCol .lsTop{ font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
td.lastCol .lsSub{ margin-top:2px; font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }


  /* Phase 0â€“3 UX: toasts + confirm */
  .toastHost{
    position:fixed;
    right:16px;
    bottom:16px;
    display:flex;
    flex-direction:column;
    gap:10px;
    z-index:10000;
    pointer-events:none;
  }
  .toast{
    pointer-events:auto;
    min-width:260px;
    max-width:min(420px, 92vw);
    border-radius:16px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(2,6,23,.92);
    backdrop-filter: blur(10px);
    padding:10px 12px;
    box-shadow: 0 14px 34px rgba(0,0,0,.45);
  }
  .toast .tTop{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;}
  .toast .tTitle{font-weight:900;font-size:13px;letter-spacing:.2px;}
  .toast .tMsg{margin-top:4px;color:var(--muted);font-size:12px;line-height:1.35;}
  .toast .tClose{border:none;background:transparent;color:var(--muted);cursor:pointer;font-weight:900;line-height:1;padding:2px 6px;border-radius:10px;}
  .toast .tClose:hover{background:rgba(255,255,255,.08);color:var(--text);}
  .toast[data-kind="success"]{border-color:rgba(34,197,94,.35);}
  .toast[data-kind="warn"]{border-color:rgba(245,158,11,.35);}
  .toast[data-kind="error"]{border-color:rgba(239,68,68,.35);}

  .confirmOverlay{
    position:fixed; inset:0;
    background:rgba(2,6,23,.72);
    backdrop-filter: blur(6px);
    display:none;
    align-items:center;
    justify-content:center;
    padding:22px 14px;
    z-index:10001;
  }
  .confirmCard{
    width:min(520px, 96vw);
    border:1px solid rgba(255,255,255,.10);
    background:rgba(15,23,42,.96);
    border-radius:18px;
    box-shadow: 0 24px 60px rgba(0,0,0,.55);
    padding:14px;
  }
  .confirmTitle{font-weight:900;font-size:15px;}
  .confirmMsg{margin-top:6px;color:var(--muted);font-size:13px;line-height:1.4;white-space:pre-line;}
  .confirmActions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap;}
  .confirmActions .btn{min-width:96px;}

  /* Controls wrap better on narrow widths */
  .controls{flex-wrap:wrap;}
  .controls .input{height:36px;border-radius:12px;}


/* Hover tooltips (offline-safe; works on file://) */
.uiTooltip{
  position: fixed;
  left: 0; top: 0;
  z-index: 99999;
  display: none;
  max-width: 340px;
  padding: 10px 12px;
  border-radius: 12px;
  background: linear-gradient(180deg, rgba(37, 99, 235, 0.98), rgba(30, 64, 175, 0.98));
  color: rgba(255,255,255,0.96);
  border: 1px solid rgba(191, 219, 254, 0.35);
  box-shadow: 0 14px 40px rgba(0,0,0,.45);
  font-size: 12.5px;
  line-height: 1.3;
  pointer-events: none;
  white-space: normal;
}

th[data-tip]{cursor:help;}


/* Tiny icon buttons (help) */
.iconBtn{
  height: 34px;
  width: 34px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: rgba(226,232,240,.92);
  font-weight: 900;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.iconBtn:hover{ background: rgba(255,255,255,.10); }

/* Scope lock chip */
.lockChip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  margin-left: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: rgba(226,232,240,.92);
}
.lockChip b{ font-weight: 900; }

/* Toast action button */
.toast .tActions{ display:flex; gap:10px; margin-top:10px; align-items:center; }
.toast .tAction{
  border-radius: 10px;
  padding: 6px 10px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.08);
  color: rgba(226,232,240,.92);
  cursor:pointer;
  font-weight: 800;
}
.toast .tAction:hover{ background: rgba(255,255,255,.12); }

/* Command palette (Ctrl/Cmd+K) */
.cmdkOverlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: flex-start;
  justify-content: center;
  padding-top: 10vh;
  z-index: 99998;
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(6px);
}
.cmdkCard{
  width: min(720px, calc(100vw - 24px));
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(2, 6, 23, 0.92);
  box-shadow: 0 20px 70px rgba(0,0,0,.65);
  overflow: hidden;
}
.cmdkTop{
  padding: 14px 14px 10px 14px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  display:flex;
  gap:10px;
  align-items:center;
}
.cmdkInput{
  width: 100%;
  height: 40px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: rgba(226,232,240,.92);
  padding: 0 12px;
  outline: none;
}
.cmdkList{ max-height: 360px; overflow:auto; padding: 8px; }
.cmdkItem{
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap:10px;
  padding: 10px 10px;
  border-radius: 12px;
  cursor:pointer;
}
.cmdkItem:hover, .cmdkItem[aria-selected="true"]{ background: rgba(255,255,255,.08); }
.cmdkKbd{
  font-size: 12px;
  opacity: .8;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  padding: 4px 8px;
  border-radius: 10px;
  white-space: nowrap;
}

/* Import stepper */
.impStepper{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin: 10px 0 12px 0;
}
.impStep{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 8px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: rgba(226,232,240,.92);
  font-size: 12px;
  font-weight: 900;
}
.impStep[data-state="todo"]{ opacity:.65; }
.impStep[data-state="doing"]{ border-color: rgba(191,219,254,.35); }
.impStep[data-state="done"]{ border-color: rgba(34,197,94,.45); }

</style>
<style>
      .scoreCell{ cursor:pointer; text-decoration: underline dotted rgba(255,255,255,.25); text-underline-offset: 2px; }
      .scoreCell:hover{ text-decoration-color: rgba(255,255,255,.55); }
      .chip.impact{ font-weight:900; }
      .chip.impact.good{ border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); color: rgba(220,252,231,.95); }
      .chip.impact.neutral{ border-color: rgba(148,163,184,.28); background: rgba(148,163,184,.10); color: rgba(226,232,240,.92); }
      .chip.impact.bad{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); color: rgba(254,226,226,.95); }
      #guideOverlay{ display:none; }

      /* Phase 4: column visibility */
      .rankWrap{ overflow:auto; }
      .rankWrap.hide-rank [data-col="rank"], .rankWrap.hide-rank th[data-col="rank"],
      .rankWrap.hide-conf [data-col="conf"], .rankWrap.hide-conf th[data-col="conf"],
      .rankWrap.hide-vert [data-col="vert"], .rankWrap.hide-vert th[data-col="vert"],
      .rankWrap.hide-mr [data-col="mr"], .rankWrap.hide-mr th[data-col="mr"],
      .rankWrap.hide-sd [data-col="sd"], .rankWrap.hide-sd th[data-col="sd"],
      .rankWrap.hide-life [data-col="life"], .rankWrap.hide-life th[data-col="life"],
      .rankWrap.hide-trend [data-col="trend"], .rankWrap.hide-trend th[data-col="trend"],
      .rankWrap.hide-last [data-col="last"], .rankWrap.hide-last th[data-col="last"]{ display:none !important; }


/* Trend popover (click Trend pill) */
.pillTrend{ cursor:pointer; }
.pillTrend:focus{ outline: 2px solid rgba(148,163,184,.45); outline-offset: 2px; }

#trendPop{ position:fixed; inset:0; display:none; z-index: 99999; }
#trendPop.show{ display:block; }
#trendPop .trendCard{
  position:fixed;
  width: 340px;
  max-width: calc(100vw - 24px);
  border-radius: 18px;
  border:1px solid rgba(148,163,184,.24);
  background: rgba(2,6,23,.94);
  box-shadow: 0 24px 80px rgba(0,0,0,.55);
  padding: 14px 14px 12px;
  color: rgba(226,232,240,.96);
}
#trendPop .trendHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
#trendPop .trendTitle{ font-size: 22px; font-weight: 900; letter-spacing: .2px; }
#trendPop .trendClose{
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  color: rgba(226,232,240,.92);
  border-radius: 12px;
  height: 34px;
  width: 34px;
  display:grid;
  place-items:center;
  cursor:pointer;
}
#trendPop .trendClose:hover{ background: rgba(148,163,184,.12); }

#trendPop .trendRow{ display:flex; align-items:center; gap:12px; }
#trendPop .trendIcon{
  width: 44px; height: 44px;
  border-radius: 14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  display:grid; place-items:center;
  font-weight: 900;
}
#trendPop .trendIcon.good{ border-color: rgba(34,197,94,.32); background: rgba(34,197,94,.10); color: rgba(220,252,231,.95); }
#trendPop .trendIcon.bad{  border-color: rgba(239,68,68,.32); background: rgba(239,68,68,.10); color: rgba(254,226,226,.95); }
#trendPop .trendIcon.neutral{ border-color: rgba(148,163,184,.26); background: rgba(148,163,184,.08); color: rgba(226,232,240,.92); }

#trendPop .trendSpark{ width: 240px; height: 56px; display:block; }
#trendPop .sparkPath{ fill:none; stroke: rgba(148,163,184,.85); stroke-width:3; stroke-linecap:round; }
#trendPop .sparkDot{ fill: rgba(226,232,240,.92); }
#trendPop .sparkPath.good{ stroke: rgba(34,197,94,.9); }
#trendPop .sparkPath.bad{  stroke: rgba(239,68,68,.9); }
#trendPop .sparkPath.neutral{ stroke: rgba(148,163,184,.85); }
#trendPop .trendText{ margin-top: 10px; color: var(--muted); font-size: 13px; line-height: 1.35; }

/* Columns modal */
      #colsOverlay{ display:none; }
      .colsGrid{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
      .colsGrid label{ display:flex; gap:10px; align-items:center; padding:10px; border-radius:12px;
        border:1px solid rgba(148,163,184,.22); background: rgba(148,163,184,.06); }
      .colsGrid input{ transform: translateY(1px); }
      .colsHint{ color: var(--muted); font-size: 12px; margin-top: 8px; }
</style><style>
            .captureFixedShim { position: absolute !important; }
            .captureStickyShim { position: static !important; }
            .captureHeaderShim { position: relative !important; }
        </style><style id="ar11fa31b299astyle">
				.ar11fa31b299ahidden{ position:absolute !important; opacity:0 !important; pointer-events:none !important}
			</style><style>
      .scoreCell{ cursor:pointer; text-decoration: underline dotted rgba(255,255,255,.25); text-underline-offset: 2px; }
      .scoreCell:hover{ text-decoration-color: rgba(255,255,255,.55); }
      .chip.impact{ font-weight:900; }
      .chip.impact.good{ border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); color: rgba(220,252,231,.95); }
      .chip.impact.neutral{ border-color: rgba(148,163,184,.28); background: rgba(148,163,184,.10); color: rgba(226,232,240,.92); }
      .chip.impact.bad{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); color: rgba(254,226,226,.95); }
      #guideOverlay{ display:none; }

      /* Phase 4: column visibility */
      .rankWrap{ overflow:auto; }
      .rankWrap.hide-rank [data-col="rank"], .rankWrap.hide-rank th[data-col="rank"],
      .rankWrap.hide-conf [data-col="conf"], .rankWrap.hide-conf th[data-col="conf"],
      .rankWrap.hide-vert [data-col="vert"], .rankWrap.hide-vert th[data-col="vert"],
      .rankWrap.hide-mr [data-col="mr"], .rankWrap.hide-mr th[data-col="mr"],
      .rankWrap.hide-sd [data-col="sd"], .rankWrap.hide-sd th[data-col="sd"],
      .rankWrap.hide-life [data-col="life"], .rankWrap.hide-life th[data-col="life"],
      .rankWrap.hide-trend [data-col="trend"], .rankWrap.hide-trend th[data-col="trend"],
      .rankWrap.hide-last [data-col="last"], .rankWrap.hide-last th[data-col="last"]{ display:none !important; }


/* Trend popover (click Trend pill) */
.pillTrend{ cursor:pointer; }
.pillTrend:focus{ outline: 2px solid rgba(148,163,184,.45); outline-offset: 2px; }

#trendPop{ position:fixed; inset:0; display:none; z-index: 99999; }
#trendPop.show{ display:block; }
#trendPop .trendCard{
  position:fixed;
  width: 340px;
  max-width: calc(100vw - 24px);
  border-radius: 18px;
  border:1px solid rgba(148,163,184,.24);
  background: rgba(2,6,23,.94);
  box-shadow: 0 24px 80px rgba(0,0,0,.55);
  padding: 14px 14px 12px;
  color: rgba(226,232,240,.96);
}
#trendPop .trendHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
#trendPop .trendTitle{ font-size: 22px; font-weight: 900; letter-spacing: .2px; }
#trendPop .trendClose{
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  color: rgba(226,232,240,.92);
  border-radius: 12px;
  height: 34px;
  width: 34px;
  display:grid;
  place-items:center;
  cursor:pointer;
}
#trendPop .trendClose:hover{ background: rgba(148,163,184,.12); }

#trendPop .trendRow{ display:flex; align-items:center; gap:12px; }
#trendPop .trendIcon{
  width: 44px; height: 44px;
  border-radius: 14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  display:grid; place-items:center;
  font-weight: 900;
}
#trendPop .trendIcon.good{ border-color: rgba(34,197,94,.32); background: rgba(34,197,94,.10); color: rgba(220,252,231,.95); }
#trendPop .trendIcon.bad{  border-color: rgba(239,68,68,.32); background: rgba(239,68,68,.10); color: rgba(254,226,226,.95); }
#trendPop .trendIcon.neutral{ border-color: rgba(148,163,184,.26); background: rgba(148,163,184,.08); color: rgba(226,232,240,.92); }

#trendPop .trendSpark{ width: 240px; height: 56px; display:block; }
#trendPop .sparkPath{ fill:none; stroke: rgba(148,163,184,.85); stroke-width:3; stroke-linecap:round; }
#trendPop .sparkDot{ fill: rgba(226,232,240,.92); }
#trendPop .sparkPath.good{ stroke: rgba(34,197,94,.9); }
#trendPop .sparkPath.bad{  stroke: rgba(239,68,68,.9); }
#trendPop .sparkPath.neutral{ stroke: rgba(148,163,184,.85); }
#trendPop .trendText{ margin-top: 10px; color: var(--muted); font-size: 13px; line-height: 1.35; }

/* Columns modal */
      #colsOverlay{ display:none; }
      .colsGrid{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
      .colsGrid label{ display:flex; gap:10px; align-items:center; padding:10px; border-radius:12px;
        border:1px solid rgba(148,163,184,.22); background: rgba(148,163,184,.06); }
      .colsGrid input{ transform: translateY(1px); }
      .colsHint{ color: var(--muted); font-size: 12px; margin-top: 8px; }
</style><style>
            .captureFixedShim { position: absolute !important; }
            .captureStickyShim { position: static !important; }
            .captureHeaderShim { position: relative !important; }
        </style><link href="./BarrelTracker â€” v4.5.24_files/css2" rel="stylesheet"><style id="ar2f2dae4ad6style">
				.ar2f2dae4ad6hidden{ position:absolute !important; opacity:0 !important; pointer-events:none !important}
			</style></head>
<body data-mode="timeline" class="">
  <div class="wrap">
    <header class="suiteHeader">
  <div class="suiteHeader__left">
    <div class="suiteHeader__topline">
      <div class="suiteHeader__title">BarrelTracker</div>
      <div class="suiteHeader__pill" id="pillVersion">v4.5.24</div>
      <div class="suiteHeader__pill suiteHeader__pill--muted">standalone</div>
    </div>
    <div class="suiteHeader__tagline">Offline barrel performance tracker (v4.5.24) â€” import sessions, rank barrels, review trends.</div>
  </div>
  <div class="suiteHeader__right">
    <div class="suiteHeader__actions">
      <div class="suiteHeader__pill">Vertical-first</div>
      <div class="suiteHeader__pill">Confidence-weighted</div>
      <div class="suiteHeader__pill">Sighters count toward rounds</div>
      <button id="btnClear" class="btn">Clear</button>
      <button id="btnLockScope" class="btn" data-tip="Freeze rankings to prevent accidental scope changes mid-match">Lock scope</button>
      <span id="scopeLockChip" class="lockChip" data-tip="Scope is live. Rankings update when you change the Form window." style="display: inline-flex;">ðŸ”“ <b>Live</b></span>
      <button id="btnGuide" class="btn">Guide</button>
    </div>
    <div class="suiteHeader__badge" data-tip="BarrelTracker">
      <img class="suiteHeader__badgeImg" alt="" src="data:image/jpeg;base64,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">
    </div>
  </div>
</header>

    <div class="panel">
      <div class="panelHead">
        <div>
          <h2>Barrel Ranking â€” Current Form <span class="helpIcon" data-tip="Ranking score (0â€“100) uses fixed v1 weights: Score = clamp(100 âˆ’ VertÃ—Wv âˆ’ MRÃ—Wmr âˆ’ SDÃ—Wsd, 0, 100) Ã— ConfMult. Wv=60, Wmr=20, Wsd=1.2. ConfMult: High 1.00, Mod 0.90, Low 0.78. Lower Vert/MR/SD is better; confidence only scales the result.">?</span></h2>
          <div class="note">Last <span id="lblWindow">800</span> rounds Â· Min confidence: <span id="lblMinConf">Moderate</span> Â· <span id="lblSighters">Show sighters</span></div>
          <div class="hint"></div>
        </div>
        <div class="controls">
          <select id="selWindow" class="select" style="">
            <option value="200">Form window: 200 rds</option>
            <option value="400" selected="">Form window: 400 rds</option>
            <option value="800">Form window: 800 rds</option>
          </select>
          <select id="selMinConf" class="select">
            <option value="low">Min confidence: Low</option>
            <option value="mod" selected="">Min confidence: Moderate</option>
            <option value="high">Min confidence: High</option>
          </select>
          <input id="inpSearch" class="input" placeholder="Search barrelâ€¦" style="width:180px;">
          <select id="selFilter" class="select">
            <option value="all" selected="">Show: All</option>
            <option value="with">Show: With sessions</option>
            <option value="needs">Show: Needs data</option>
            <option value="lowconf">Show: Low confidence</option>
          </select>
          <select id="selSort" class="select">
            <option value="rank" selected="">Sort: Rank</option>
            <option value="conf">Sort: Confidence</option>
            <option value="vert">Sort: Vert</option>
            <option value="mr">Sort: MR</option>
            <option value="sd">Sort: SD</option>
            <option value="life">Sort: Life</option>
            <option value="last">Sort: Last</option>
          </select>
          <select id="selLayout" class="select" data-tip="Column layout preset">
            <option value="Default" selected="">Layout: Default</option>
            <option value="Compact">Layout: Compact</option>
            <option value="Scoring">Layout: Scoring</option>
            <option value="Custom">Layout: Custom</option>
          </select>
          <button class="btn" id="btnResetView" data-tip="Reset search, filters, sort, layout and scope to defaults">Reset view</button>
          <button class="btn" id="btnColumns" data-tip="Choose which columns to show">Columns</button>
          <label class="toggle"><input id="chkSighters" type="checkbox" checked=""> Show sighters</label>
          <button class="btn primary" id="btnImportGlobal">Import</button>
          <button class="btn" id="btnImportJSON">Import JSON</button>
          <button class="btn" id="btnExport">Export</button>
          <button class="iconBtn" id="btnQuickHelp" aria-label="Help" data-tip="Help â€¢ Shortcuts (? / Ctrl+K)">?</button>
          <input id="fileImportJSON" type="file" accept=".json,application/json" style="display:none">
          <button class="btn" id="btnAddBarrel">+ Barrel</button>

      <!-- + Barrel popover -->
      <div id="barrelPop" class="pop" style="display: none;">
        <div class="popHead">Add barrel</div>
        <div class="popBody">
          <div class="popRow">
            <label class="popLbl">Barrel ID</label>
            <input id="inpBarrelId" class="select" placeholder="e.g., B6">
          </div>
          <div class="popRow">
            <label class="popLbl">Twist (optional)</label>
            <div style="display:grid;grid-template-columns: 1fr; gap:10px;">
              <select id="inpBarrelTwist" class="select">
                <option value="">â€”</option>
                <option value="8.5">8.5"</option>
                <option value="9.0">9.0"</option>
                <option value="custom">Customâ€¦</option>
              </select>
              <input id="inpBarrelTwistCustom" class="input" type="number" step="0.1" min="0" placeholder="e.g., 7.5" style="display:none;">
            </div>
          </div>
          
          <div class="popRow">
            <label class="popLbl">Starting rounds</label>
            <input id="inpBarrelStartRounds" class="input" type="number" min="0" step="1" placeholder="e.g., 1200">
          </div>
          <div class="mini" style="margin:-2px 0 10px 0; opacity:.9;">Adds an offset to <b>Life</b> only (does not affect rankings or window stats).</div>
<div class="popActions">
            <button class="btn sm" id="btnBarrelCancel">Cancel</button>
            <button class="btn sm primary" id="btnBarrelSave">Save</button>
          </div>
          <div class="mini" style="margin-top:6px;">Barrels are just containers. Most sessions arrive via imports.</div>
        </div>
      </div>

</div>
      </div>

      <div id="rankWrap" class="rankWrap" style="overflow:auto;">
        <table>
          <thead>
            <tr>
              <th data-col="idx">#</th>
              <th data-col="barrel">Barrel</th>
              <th data-col="rank">Rank</th>
              <th data-col="conf" data-tip="Confidence (trust): sample size + consistency + data quality. Scales Rank; doesnâ€™t create performance.">Conf</th>
              <th data-col="vert">Vert (MOA)</th>
              <th data-col="mr">MR (MOA)</th>
              <th data-col="sd">SD (fps)</th>
              <th data-col="life">Life</th>
              <th data-col="trend" data-tip="Trend vs rolling baseline in this window. â–² improving, â–¼ degrading, â€¢ flat. Click the icon for details.">Trend</th>
              <th data-col="last" class="lastCol">Last session</th>
            </tr>
          </thead>
          <tbody id="rankBody"><tr class="row" style="outline: rgba(99, 102, 241, 0.35) solid 2px; outline-offset: -2px;">
          <td data-col="idx">1</td>
          <td data-col="barrel" class="barrel">Brux-02</td>
          <td data-col="rank"><b>42.0</b></td>
          <td data-col="conf"><span class="conf high" data-tip="Confidence: High">High</span></td>
          <td data-col="vert">0.67</td>
          <td data-col="mr">0.22</td>
          <td data-col="sd">11.3</td>
          <td data-col="life">1254</td>
          <td data-col="trend"><button type="button" class="trendMini trend down" data-trend="Brux-02" data-tip="Trend: Down"><span class="trendwrap"><span class="arrow">â–¼</span><svg class="spark" viewBox="0 0 80 18" aria-hidden="true">
                <path d="M2 4 L16 6 L30 8 L44 10 L58 12 L72 14"></path>
                <circle class="dot" cx="72" cy="14" r="2.5"></circle>
              </svg></span></button></td>
          <td data-col="last" class="lastCol"><div class="lsTop" data-tip="Oct 11, 2025 â€” SM_shotslog_Oct
Oct 11">Oct 11, 2025 â€” SM_shotslog_Oct</div><div class="lsSub">Oct 11</div></td>
        </tr><tr class="row">
          <td data-col="idx">2</td>
          <td data-col="barrel" class="barrel">Brux-01</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">400</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        </tr><tr class="row">
          <td data-col="idx">3</td>
          <td data-col="barrel" class="barrel">Brux-1</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">0</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        </tr><tr class="row">
          <td data-col="idx">4</td>
          <td data-col="barrel" class="barrel">Brux-2</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">0</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        </tr><tr class="row">
          <td data-col="idx">5</td>
          <td data-col="barrel" class="barrel">Krieger-1</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">0</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        </tr><tr class="row">
          <td data-col="idx">6</td>
          <td data-col="barrel" class="barrel">Krieger-2</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">0</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        </tr></tbody>
        </table>
      </div>
    </div>

    <div class="drawer">
      <div class="card" id="detailCard">
        <div class="cardHead">
          <div>
            <h3 id="detailTitle">Brux-02 â€” Timeline</h3>
            <div class="small" id="detailSub">Current form window: last 800 rounds Â· Confidence: High</div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
            <div class="small" id="detailMeta">Life: 1254 rds</div>
            <div id="detailActions" style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;">
      <button class="btn sm primary" id="btnOpenImport">Import</button>
      <button class="btn sm" id="btnOpenManual">+ Manual</button>
      <button class="btn sm danger" id="btnDeleteBarrel" data-tip="Delete this barrel (and its sessions)">Delete barrel</button>
    </div>
          </div>
        </div>
        <div class="cardBody" id="detailBody">
      <div class="sessionRow" data-sid="S_1767586453768_ac306bf6872cd8">
        <div class="rowTop">
          <div class="sessionTitle">Oct 11, 2025 â€” SM_shotslog_Oct</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453768_ac306bf6872cd8" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.56 MOA</span><span class="chip">MR 0.19 MOA</span><span class="chip">SD 10.8 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact good" data-tip="Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD.">ðŸŸ¢ Helped barrel</span></div>
        <div class="fileLine">SM_shotslog_Oct.csv (T1) + Rifle_Bullet_2025-10-11_09-08-06.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767586453769_0c0cc00b2f858">
        <div class="rowTop">
          <div class="sessionTitle">Oct 11, 2025 â€” SM_shotslog_Oct</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453769_0c0cc00b2f858" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.68 MOA</span><span class="chip">MR 0.22 MOA</span><span class="chip">SD 9.9 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact neutral" data-tip="Session impact vs rolling baseline: within the noise band (no clear improvement/regression).">âšª Neutral</span></div>
        <div class="fileLine">SM_shotslog_Oct.csv (T2) + Rifle_Bullet_2025-10-11_09-49-30.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767586453769_1c49cf78ea693">
        <div class="rowTop">
          <div class="sessionTitle">Oct 11, 2025 â€” SM_shotslog_Oct</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453769_1c49cf78ea693" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/26</span><span class="chip">Vert 0.86 MOA</span><span class="chip">MR 0.25 MOA</span><span class="chip">SD 29.0 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact bad" data-tip="Session impact vs rolling baseline: worsened Vert by â‰¥0.05 MOA and increased SD by â‰¥0.5 fps.">ðŸ”´ Hurt confidence</span></div>
        <div class="fileLine">SM_shotslog_Oct.csv (T3) + Rifle_Bullet_2025-10-11_08-19-43.xls</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767566247547_4e4be750489238">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767566247547_4e4be750489238" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.57 MOA</span><span class="chip">MR 0.22 MOA</span><span class="chip">SD 9.9 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact good" data-tip="Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD.">ðŸŸ¢ Helped barrel</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T1) + Rifle_Bullet_2025-09-25_08-10-02.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767566247547_98aa02b1c7eb98">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767566247547_98aa02b1c7eb98" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.57 MOA</span><span class="chip">MR 0.21 MOA</span><span class="chip">SD 6.4 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact good" data-tip="Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD.">ðŸŸ¢ Helped barrel</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T2) + Rifle_Bullet_2025-09-07_08-10-13.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767566247547_23855feac9a2b8">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767566247547_23855feac9a2b8" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.83 MOA</span><span class="chip">MR 0.21 MOA</span><span class="chip">SD 9.5 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact neutral" data-tip="Session impact vs rolling baseline: within the noise band (no clear improvement/regression).">âšª Neutral</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T3) + Rifle_Bullet_2025-09-13_11-45-46.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767586453768_ba08993284cf7">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453768_ba08993284cf7" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.57 MOA</span><span class="chip">MR 0.22 MOA</span><span class="chip">SD 9.9 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact good" data-tip="Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD.">ðŸŸ¢ Helped barrel</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T1) + Rifle_Bullet_2025-09-25_08-10-02.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767586453768_f2d8bbd1f56cb8">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453768_f2d8bbd1f56cb8" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.57 MOA</span><span class="chip">MR 0.21 MOA</span><span class="chip">SD 6.4 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact good" data-tip="Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD.">ðŸŸ¢ Helped barrel</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T2) + Rifle_Bullet_2025-09-07_08-10-13.csv</div>
      </div>
    
      <div class="sessionRow" data-sid="S_1767586453768_a5ab6ddaf6d6d8">
        <div class="rowTop">
          <div class="sessionTitle">Sep 25, 2025 â€” SM_shotslog_Dec_18</div>
          <button class="iconBtn" data-action="edit" data-sid="S_1767586453768_a5ab6ddaf6d6d8" data-tip="Edit session">âœŽ</button>
        </div>
        <div class="chips"><span class="chip sighters">Record</span><span class="chip">20/22</span><span class="chip">Vert 0.83 MOA</span><span class="chip">MR 0.21 MOA</span><span class="chip">SD 9.5 fps</span><span class="chip conf high" data-tip="Confidence: High â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.">High</span><span class="chip impact neutral" data-tip="Session impact vs rolling baseline: within the noise band (no clear improvement/regression).">âšª Neutral</span></div>
        <div class="fileLine">SM_shotslog_Dec_18.csv (T3) + Rifle_Bullet_2025-09-13_11-45-46.csv</div>
      </div>
    </div>
      </div>



    </div>

    <div class="footerNote">XquiziT Arms BarrelTracker Local-only</div>
  </div>


  <!-- Score breakdown popover (Phase 1) -->
  <div id="scorePop" class="pop" style="display:none; width:360px;">
    <div class="popHead">Score breakdown</div>
    <div class="popBody" id="scorePopBody"></div>
    <div class="popActions">
      <button class="btn sm" id="btnScorePopClose">Close</button>
    </div>
  </div>

  <!-- Quick Guide modal (Phase 5) -->
  <div class="modalOverlay" id="guideOverlay" aria-hidden="true" style="display: none;">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
      <div class="modalHead">
        <div>
          <h3 id="guideTitle">BarrelTracker Quick Guide</h3>
          <div class="small" style="color:var(--muted);margin-top:6px;">How the ranking works (and how to avoid bad imports).</div>
        </div>
        <button class="iconBtn" id="btnGuideClose">âœ•</button>
      </div>
      <div class="modalBody">
        <div class="card" style="margin-bottom:14px;">
          <div class="cardHead" style="display:flex;align-items:center;justify-content:space-between;">
            <div><b>Whatâ€™s new</b> <span class="small" style="color:var(--muted);" id="whatsNewVer">v4.5.24</span></div>
            <button class="btn sm" id="btnSupportBundle" data-tip="Exports extra diagnostics to help debug issues">Export support bundle</button>
          </div>
          <div class="small" style="color:var(--muted);line-height:1.45;">
            Phase 4â€“5: Column layouts + saved visibility, tooltip help on Confidence/Trend, and schema-aware exports.
          </div>
        </div>

        <div class="tileGrid">
          <div class="tile">
            <div class="tTitle">Vertical-first philosophy</div>
            <div class="tSub">Lower <b>Vertical MOA</b> drives the score the most. MR and SD matter, but they donâ€™t outweigh a barrel that prints tall.</div>
          </div>
          <div class="tile">
            <div class="tTitle">Deterministic scoring</div>
            <div class="tSub">Score starts at 100 and subtracts penalties from Vertical, MR, and SD â€” then applies a confidence multiplier. Same inputs â†’ same rank.</div>
          </div>
          <div class="tile">
            <div class="tTitle">Confidence is â€œtrust,â€ not â€œaccuracyâ€</div>
            <div class="tSub">Confidence reflects sample size + consistency + data quality. It scales the score; it doesnâ€™t â€œcreateâ€ performance.</div>
          </div>
          <div class="tile">
            <div class="tTitle">Import guardrails</div>
            <div class="tSub">If chrono strings are short, missing, or inconsistent, youâ€™ll see warnings and confidence may be capped (explicitly shown).</div>
          </div>
          <div class="tile">
            <div class="tTitle">Match-day scope</div>
            <div class="tSub">Use the <b>Form window</b> selector (e.g., 200 / 400 rds) and optionally <b>Lock scope</b> to freeze rankings during a match.</div>
          </div>
        </div>
        <div class="footerNote">Tip: click a Score to see the full breakdown. Click a row to open the barrel timeline.</div>
      </div>
      <div class="modalFoot">
        <div class="mini">v4.5.24 â€¢ local-only</div>
        <div>
          <button class="btn" id="btnGuideOk">Close</button>
        </div>
      </div>
    </div>
  </div>


  <!-- Columns & Layout modal (Phase 4) -->
  <div class="modalOverlay" id="colsOverlay" aria-hidden="true" style="display: none;">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="colsTitle" style="max-width:720px;">
      <div class="modalHead">
        <div>
          <h3 id="colsTitle">Columns &amp; Layout</h3>
          <div class="small" style="color:var(--muted);margin-top:2px;">Choose which columns appear in the ranking table. Saved locally.</div>
        </div>
        <button class="iconBtn" id="btnColsClose">âœ•</button>
      </div>
      <div class="modalBody">
        <div class="colsGrid" id="colsGrid"><label><input type="checkbox" data-colkey="rank" checked=""> <div><b>Rank</b><div style="color:var(--muted);font-size:12px;">Toggle Rank</div></div></label><label><input type="checkbox" data-colkey="conf" checked=""> <div><b>Confidence</b><div style="color:var(--muted);font-size:12px;">Toggle Confidence</div></div></label><label><input type="checkbox" data-colkey="vert" checked=""> <div><b>Vert (MOA)</b><div style="color:var(--muted);font-size:12px;">Toggle Vert (MOA)</div></div></label><label><input type="checkbox" data-colkey="mr" checked=""> <div><b>MR (MOA)</b><div style="color:var(--muted);font-size:12px;">Toggle MR (MOA)</div></div></label><label><input type="checkbox" data-colkey="sd" checked=""> <div><b>SD (fps)</b><div style="color:var(--muted);font-size:12px;">Toggle SD (fps)</div></div></label><label><input type="checkbox" data-colkey="life" checked=""> <div><b>Life</b><div style="color:var(--muted);font-size:12px;">Toggle Life</div></div></label><label><input type="checkbox" data-colkey="trend" checked=""> <div><b>Trend</b><div style="color:var(--muted);font-size:12px;">Toggle Trend</div></div></label><label><input type="checkbox" data-colkey="last" checked=""> <div><b>Last session</b><div style="color:var(--muted);font-size:12px;">Toggle Last session</div></div></label></div>
        <div class="colsHint">Tip: pick a preset from â€œLayoutâ€, or customize here and it will save as â€œCustomâ€.</div>
      </div>
      <div class="modalFoot">
        <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
          <div style="display:flex;gap:10px;align-items:center;">
            <button class="btn" id="btnColsAll">Show all</button>
            <button class="btn" id="btnColsCompact">Compact</button>
            <button class="btn" id="btnColsReset">Reset default</button>
          </div>
          <div style="display:flex;gap:10px;align-items:center;">
            <button class="btn primary" id="btnColsOk">Done</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const APP = (window.BT_APP && typeof window.BT_APP === "object") ? window.BT_APP : { name:"BarrelTracker", version: "4.5.17" };
  const APP_VERSION_TAG = `v${APP.version}`;

  const SCHEMA_VERSION = 3; // export/import schema (migrations supported)

  // ---------- Phase 0â€“3 UX helpers ----------
  const $id = (id) => document.getElementById(id);

  function ensureToastHost(){
    let host = $id("toastHost");
    if (!host){
      host = document.createElement("div");
      host.id = "toastHost";
      host.className = "toastHost";
      host.setAttribute("aria-live","polite");
      document.body.appendChild(host);
    }
    return host;
  }

  function toast(msg, kind="success", title=null, ms=3600, opts=null){
    try{
      const host = ensureToastHost();
      const el = document.createElement("div");
      el.className = "toast";
      el.dataset.kind = kind;
      const safeTitle = title || (kind==="error" ? "Error" : kind==="warn" ? "Heads up" : "Done");

      const hasAction = !!(opts && typeof opts === "object" && opts.actionLabel && typeof opts.onAction === "function");
      el.innerHTML = `
        <div class="tTop">
          <div class="tTitle">${escapeHTML(safeTitle)}</div>
          <button class="tClose" aria-label="Dismiss">âœ•</button>
        </div>
        <div class="tMsg">${escapeHTML(String(msg||""))}</div>
        ${hasAction ? `<div class="tActions"><button class="tAction" type="button">${escapeHTML(String(opts.actionLabel))}</button></div>` : ``}
      `;
      el.querySelector(".tClose").addEventListener("click", () => el.remove());

      if (hasAction){
        el.querySelector(".tAction")?.addEventListener("click", () => {
          try{ opts.onAction(); }catch(e){ if (window.BT_APP && window.BT_APP.debug) console.warn(e); }
          try{ el.remove(); }catch{}
        });
      }

      host.appendChild(el);
      if (ms > 0){
        setTimeout(() => { try{ el.remove(); }catch{} }, ms);
      }
      return el;
    }catch{
      // last resort (release build: avoid console noise)
      return null;
    }
  }

  // ---------- UX helpers (vNext polish) ----------
  const AUTOSAVE_KEY = "BT_DATA_V1";
  let _autosaveTimer = null;

  function deepClone(obj){
    try{
      if (typeof structuredClone === "function") return structuredClone(obj);
    }catch{}
    return JSON.parse(JSON.stringify(obj));
  }

  function snapshotAppState(){
    // Include everything needed for undo operations & restore.
    return deepClone({
      barrels: state.barrels,
      sessions: state.sessions,
      selectedBarrelId: state.selectedBarrelId,
      windowRounds: state.windowRounds,
      minConf: state.minConf,
      showSighters: state.showSighters,
      ui: state.ui,
      rankLocked: state.rankLocked,
      lockedWindowRounds: state.lockedWindowRounds,
      lockedAtISO: state.lockedAtISO,
      detailMode: state.detailMode,
      importer: state.importer,
      draft: state.draft
    });
  }

  function restoreAppState(snap){
    if (!snap || typeof snap !== "object") return;
    state.barrels = Array.isArray(snap.barrels) ? snap.barrels : state.barrels;
    state.sessions = Array.isArray(snap.sessions) ? snap.sessions : state.sessions;
    state.selectedBarrelId = snap.selectedBarrelId ?? state.selectedBarrelId;
    state.windowRounds = Number.isFinite(snap.windowRounds) ? snap.windowRounds : state.windowRounds;
    state.minConf = snap.minConf || state.minConf;
    state.showSighters = (typeof snap.showSighters === "boolean") ? snap.showSighters : state.showSighters;
    state.ui = (snap.ui && typeof snap.ui === "object") ? snap.ui : state.ui;
    state.rankLocked = !!snap.rankLocked;
    state.lockedWindowRounds = snap.lockedWindowRounds ?? null;
    state.lockedAtISO = snap.lockedAtISO ?? null;
    state.detailMode = snap.detailMode || "timeline";
    state.importer = snap.importer ?? null;
    state.draft = snap.draft ?? null;
    bumpRev();
    render();
  }

  function buildAutosavePayload(){
    return {
      v: 1,
      savedAtISO: new Date().toISOString(),
      barrels: state.barrels,
      sessions: state.sessions,
      selectedBarrelId: state.selectedBarrelId,
      windowRounds: state.windowRounds,
      minConf: state.minConf,
      showSighters: state.showSighters,
      ui: state.ui,
      rankLocked: state.rankLocked,
      lockedWindowRounds: state.lockedWindowRounds,
      lockedAtISO: state.lockedAtISO
    };
  }

  function writeAutosave(){
    try{
      const payload = buildAutosavePayload();
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
    }catch(e){
      // ignore
    }
  }

  function scheduleAutosave(){
    try{
      clearTimeout(_autosaveTimer);
      _autosaveTimer = setTimeout(writeAutosave, 650);
    }catch{}
  }

  function readAutosaveMeta(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if (!raw) return null;
      const p = JSON.parse(raw);
      if (!p || typeof p !== "object") return null;
      const barrels = Array.isArray(p.barrels) ? p.barrels.length : 0;
      const sessions = Array.isArray(p.sessions) ? p.sessions.length : 0;
      return {
        savedAtISO: p.savedAtISO || null,
        barrels,
        sessions
      };
    }catch{
      return null;
    }
  }

  function applyAutosave(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if (!raw) return false;
      const p = JSON.parse(raw);
      if (!p || typeof p !== "object") return false;

      // Apply safe fields only
      state.barrels = Array.isArray(p.barrels) ? p.barrels : state.barrels;
      state.sessions = Array.isArray(p.sessions) ? p.sessions : state.sessions;
      state.selectedBarrelId = p.selectedBarrelId ?? state.selectedBarrelId;
      state.windowRounds = Number.isFinite(p.windowRounds) ? p.windowRounds : state.windowRounds;
      state.minConf = p.minConf || state.minConf;
      state.showSighters = (typeof p.showSighters === "boolean") ? p.showSighters : state.showSighters;
      state.ui = (p.ui && typeof p.ui === "object") ? p.ui : state.ui;
      state.rankLocked = !!p.rankLocked;
      state.lockedWindowRounds = p.lockedWindowRounds ?? null;
      state.lockedAtISO = p.lockedAtISO ?? null;

      // Clear transient UI
      state.detailMode = "timeline";
      state.importer = null;
      state.draft = null;

      normalizeState();
      bumpRev();
      return true;
    }catch{
      return false;
    }
  }

  
  function normalizeState(){
    // Barrels
    if (!Array.isArray(state.barrels)) state.barrels = [];
    state.barrels = state.barrels.map(b => {
      const o = (b && typeof b === "object") ? { ...b } : { id: String(b || "") };
      o.id = String(o.id || "").trim();
      if (!o.id) return null;

      const sr = Number(o.startRounds);
      o.startRounds = (Number.isFinite(sr) && sr > 0) ? Math.floor(sr) : 0;

      if (o.twist != null) o.twist = String(o.twist).trim();
      return o;
    }).filter(Boolean);

    // Sessions
    if (!Array.isArray(state.sessions)) state.sessions = [];
    state.sessions = state.sessions.map(s => {
      if (!s || typeof s !== "object") return null;
      const o = { ...s };
      o.id = String(o.id || "").trim() || (`S${Math.random().toString(16).slice(2,10)}`);
      o.barrelId = String(o.barrelId || "").trim();
      if (!o.barrelId) return null;

      o.isSighters = !!o.isSighters;
      if (!o.confidence) o.confidence = "mod";

      const nums = ["shotsUsed","shotsTotal","vert","mr","sd"];
      for (const k of nums){
        if (o[k] == null) continue;
        const n = Number(o[k]);
        o[k] = Number.isFinite(n) ? n : 0;
      }
      // Keep shotsTotal integer-ish
      if (Number.isFinite(o.shotsTotal)) o.shotsTotal = Math.max(0, Math.floor(o.shotsTotal));
      if (Number.isFinite(o.shotsUsed))  o.shotsUsed  = Math.max(0, Math.floor(o.shotsUsed));
      return o;
    }).filter(Boolean);

    // Selected barrel sanity
    if (state.selectedBarrelId && !state.barrels.some(b => b.id === state.selectedBarrelId)){
      state.selectedBarrelId = state.barrels[0]?.id || "";
    }
  }


function clearAutosave(){
    try{ localStorage.removeItem(AUTOSAVE_KEY); }catch{}
  }

  async function maybeOfferRestoreAutosave(){
    const meta = readAutosaveMeta();
    if (!meta || !(meta.barrels || meta.sessions)) return;

    const when = meta.savedAtISO ? new Date(meta.savedAtISO).toLocaleString() : "recently";
    const ok = await confirmDialog(
      `Restore your last autosave from ${when}?\n\nBarrels: ${meta.barrels}\nSessions: ${meta.sessions}\n\n(You can also ignore this and continue.)`,
      { title: "Restore autosave?", okText: "Restore", cancelText: "Not now" }
    );

    if (ok){
      const did = applyAutosave();
      if (did){
        toast("Autosave restored.", "success", "Restored", 5200, { actionLabel:"Forget autosave", onAction: clearAutosave });
      }else{
        toast("Couldnâ€™t restore autosave.", "error");
      }
    }
  }

  function purgeNativeTooltips(root=document){
    try{
      const els = root.querySelectorAll("[title]");
      els.forEach(el => {
        const title = (el.getAttribute("title") || "").trim();
        if (!title) { el.removeAttribute("title"); return; }
        if (!el.getAttribute("data-tip")) el.setAttribute("data-tip", title);
        el.removeAttribute("title");
      });
    }catch{}
  }

  function resetView(){
    // Ranking defaults
    state.windowRounds = 400;
    state.minConf = "mod";
    state.showSighters = true;

    // UI defaults
    ensureUi();
    state.ui.search = "";
    state.ui.filter = "all";
    state.ui.sort = "rank";
    state.ui.layout = "Default";
    state.ui.colVis = defaultColVis();
    saveUiPrefs();

    // Scope lock off
    state.rankLocked = false;
    state.lockedWindowRounds = null;
    state.lockedAtISO = null;

    // Sync controls
    const sw = $("selWindow"); if (sw) { sw.value = "400"; sw.disabled = false; }
    const mc = $("selMinConf"); if (mc) mc.value = "mod";
    const ss = $("chkSighters"); if (ss) ss.checked = true;
    const se = $("inpSearch"); if (se) se.value = "";
    const sf = $("selFilter"); if (sf) sf.value = "all";
    const so = $("selSort"); if (so) so.value = "rank";
    const sl = $("selLayout"); if (sl) sl.value = "Default";

    render();
    toast("View reset to defaults.", "success");
  }

  function isTypingContext(){
    const a = document.activeElement;
    if (!a) return false;
    const tag = (a.tagName || "").toLowerCase();
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (a.isContentEditable) return true;
    return false;
  }

  // Command palette
  let _cmdkItems = [];
  let _cmdkIndex = 0;

  function getCmdkOverlay(){ return $("cmdkOverlay"); }
  function getCmdkInput(){ return $("cmdkInput"); }
  function getCmdkList(){ return $("cmdkList"); }

  function buildCmdkItems(){
    const hasAutosave = !!readAutosaveMeta();
    return [
      { id:"focusSearch", label:"Focus search", kbd:"/", run:() => $("inpSearch")?.focus?.() },
      { id:"resetView", label:"Reset view to defaults", kbd:"", run: resetView },
      { id:"guide", label:"Open guide", kbd:"?", run: () => $("btnGuide")?.click?.() },
      { id:"import", label:"Import for selected barrel", kbd:"I", run: () => openImport(state.selectedBarrelId) },
      { id:"manual", label:"Add manual session", kbd:"M", run: () => openAddSession(state.selectedBarrelId) },
      { id:"scope", label: state.rankLocked ? "Unlock scope" : "Lock scope", kbd:"L", run: () => $("btnLockScope")?.click?.() },
      ...(hasAutosave ? [{ id:"restoreAutosave", label:"Restore autosaveâ€¦", kbd:"", run: async () => { await maybeOfferRestoreAutosave(); render(); } }] : []),
      ...(hasAutosave ? [{ id:"forgetAutosave", label:"Forget autosave", kbd:"", run: () => { clearAutosave(); toast("Autosave cleared.", "warn"); } }] : []),
    ];
  }

  function openCmdk(){
    const ov = getCmdkOverlay();
    if (!ov) return;
    _cmdkItems = buildCmdkItems();
    _cmdkIndex = 0;
    ov.style.display = "flex";
    const inp = getCmdkInput();
    if (inp){ inp.value = ""; setTimeout(() => inp.focus(), 0); }
    renderCmdk();
  }

  function closeCmdk(){
    const ov = getCmdkOverlay();
    if (!ov) return;
    ov.style.display = "none";
  }

  function renderCmdk(){
    const list = getCmdkList();
    const inp = getCmdkInput();
    if (!list || !inp) return;
    const q = (inp.value || "").trim().toLowerCase();
    const items = _cmdkItems.filter(it => !q || it.label.toLowerCase().includes(q));
    if (_cmdkIndex >= items.length) _cmdkIndex = Math.max(0, items.length - 1);

    list.innerHTML = items.length ? items.map((it, idx) => `
      <div class="cmdkItem" role="option" aria-selected="${idx===_cmdkIndex}" data-id="${escapeHTML(it.id)}">
        <div>${escapeHTML(it.label)}</div>
        ${it.kbd ? `<div class="cmdkKbd">${escapeHTML(it.kbd)}</div>` : `<div class="cmdkKbd" style="opacity:.35;">&nbsp;</div>`}
      </div>
    `).join("") : `<div class="mini" style="padding:10px;color:var(--muted);">No matches</div>`;

    list.querySelectorAll(".cmdkItem").forEach((row, idx) => {
      row.addEventListener("click", async () => {
        const id = row.getAttribute("data-id");
        const it = items.find(x => x.id === id);
        closeCmdk();
        if (it) await it.run();
      });
    });
  }

  async function runCmdkSelected(){
    const inp = getCmdkInput();
    if (!inp) return;
    const q = (inp.value || "").trim().toLowerCase();
    const items = _cmdkItems.filter(it => !q || it.label.toLowerCase().includes(q));
    const it = items[_cmdkIndex];
    closeCmdk();
    if (it) await it.run();
  }

  function initCmdk(){
    const ov = getCmdkOverlay();
    const inp = getCmdkInput();
    if (!ov || !inp) return;

    ov.addEventListener("mousedown", (e) => {
      if (e.target === ov) closeCmdk();
    });

    inp.addEventListener("input", renderCmdk);
    inp.addEventListener("keydown", async (e) => {
      const list = getCmdkList();
      if (e.key === "Escape"){ e.preventDefault(); closeCmdk(); return; }
      if (e.key === "ArrowDown"){ e.preventDefault(); _cmdkIndex++; renderCmdk(); list?.scrollBy?.({ top: 48, behavior:"smooth" }); return; }
      if (e.key === "ArrowUp"){ e.preventDefault(); _cmdkIndex--; if (_cmdkIndex < 0) _cmdkIndex = 0; renderCmdk(); list?.scrollBy?.({ top: -48, behavior:"smooth" }); return; }
      if (e.key === "Enter"){ e.preventDefault(); await runCmdkSelected(); return; }
    });
  }

  // Import stepper helper
  function updateImportStepper(imp){
    const host = $("impStepper");
    if (!host || !imp) return;

    const smDone = !!(imp.smTargets && imp.smTargets.length);
    const chDone = !!(imp.chronoSets && imp.chronoSets.length);

    const tCount = (imp.smTargets || []).length;
    const pairings = imp.pairings || {};
    const pairedCount = (imp.smTargets || []).filter(t => pairings[t.id]).length;
    const pairDone = (tCount > 0) && (pairedCount === tCount);

    const genDone = !!(imp.generatedAtISO);

    const step = (label, state) => `<span class="impStep" data-state="${state}">${label}</span>`;
    host.innerHTML = [
      step(`${smDone ? "âœ“" : "â€¢"} ShotMarker`, smDone ? "done" : "todo"),
      step(`${chDone ? "âœ“" : "â€¢"} Chrono`, chDone ? "done" : "todo"),
      step(`${pairDone ? "âœ“" : "â€¢"} Pair (${pairedCount}/${tCount || 0})`, (pairDone ? "done" : (smDone && chDone ? "doing" : "todo"))),
      step(`${genDone ? "âœ“" : "â€¢"} Generate`, genDone ? "done" : (pairDone ? "doing" : "todo")),
    ].join("");
  }



  function ensureConfirmUI(){
    let ov = $id("confirmOverlay");
    if (ov) return ov;
    ov = document.createElement("div");
    ov.id = "confirmOverlay";
    ov.className = "confirmOverlay";
    ov.innerHTML = `
      <div class="confirmCard" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
        <div class="confirmTitle" id="confirmTitle">Confirm</div>
        <div class="confirmMsg" id="confirmMsg"></div>
        <div class="confirmActions">
          <button class="btn sm" id="btnConfirmCancel">Cancel</button>
          <button class="btn sm primary" id="btnConfirmOK">OK</button>
        </div>
      </div>
    `;
    document.body.appendChild(ov);
    return ov;
  }

  function confirmDialog(message, { title="Confirm", okText="OK", cancelText="Cancel" } = {}){
    return new Promise((resolve) => {
      // Fallback if DOM not ready yet
      if (!document.body){
        resolve(window.confirm(message));
        return;
      }
      const ov = ensureConfirmUI();
      const card = ov.querySelector(".confirmCard");
      const t = ov.querySelector("#confirmTitle");
      const msg = ov.querySelector("#confirmMsg");
      const bOk = ov.querySelector("#btnConfirmOK");
      const bCancel = ov.querySelector("#btnConfirmCancel");

      t.textContent = title;
      msg.textContent = String(message||"");
      bOk.textContent = okText;
      bCancel.textContent = cancelText;

      const cleanup = () => {
        ov.style.display = "none";
        ov.removeEventListener("click", onBG);
        document.removeEventListener("keydown", onKey);
        bOk.onclick = null;
        bCancel.onclick = null;
      };
      const onBG = (e) => { if (e.target === ov) { cleanup(); resolve(false); } };
      const onKey = (e) => { if (e.key === "Escape"){ cleanup(); resolve(false);} };

      bOk.onclick = () => { cleanup(); resolve(true); };
      bCancel.onclick = () => { cleanup(); resolve(false); };

      ov.addEventListener("click", onBG);
      document.addEventListener("keydown", onKey);
      ov.style.display = "flex";
      // focus
      setTimeout(() => { try{ bOk.focus(); }catch{} }, 0);
    });
  }

  // Cooperative yield to keep UI responsive on big imports
  const tick = () => new Promise(r => setTimeout(r, 0));

  function bumpRev(){
    state.rev = (state.rev||0) + 1;
    // cache invalidation
    if (state._cache && state._cache.agg) state._cache.agg.clear();
    // autosave (debounced)
    scheduleAutosave();
  }


  function applyVersioning(){
    // Keep displayed version consistent across title/header/modal/etc.
    try {
      document.title = `${APP.name} â€” ${APP_VERSION_TAG}`;

      const pv = document.getElementById("pillVersion");
      if (pv) pv.textContent = APP_VERSION_TAG;
      const wnv = document.getElementById("whatsNewVer");
      if (wnv) wnv.textContent = APP_VERSION_TAG;

      const tl = document.querySelector(".suiteHeader__tagline");
      if (tl) {
        tl.textContent = tl.textContent.replace(/\(v[^)]+\)/, `(${APP_VERSION_TAG})`);
      }

      document.querySelectorAll(".modalFoot .mini").forEach(el => {
        el.textContent = el.textContent.replace(/^v[0-9][0-9.]*\s*â€¢/, `${APP_VERSION_TAG} â€¢`);
      });
    } catch (e) {
      // no-op (versioning should never block app start)
    }
  }

  applyVersioning();

  const state = {
    barrels: [{ id:"B1", display:"B1", startRounds: 0 }],
    sessions: [],
    selectedBarrelId: "B1",

    // ranking controls
    windowRounds: 400,
    minConf: "mod",
    showSighters: true,

    // Phase 1: UI state (search/filter/sort)
    ui: {
      search: "",
      filter: "all",
      sort: "rank"
    },

    // Phase 3: revision + caches
    rev: 0,
    _cache: { agg: new Map(), aggKey: "" },


    // Phase 4: match-day scope lock
    rankLocked: false,
    lockedWindowRounds: null,
    lockedAtISO: null,

    // detail drawer mode
    detailMode: "timeline", // "timeline" | "import" | "manual"
    draft: null,
importer: null
  };

  const CONF_ORDER = { low: 1, mod: 2, high: 3 };
  const CONF_LABEL = { low: "Low", mod: "Moderate", high: "High" };

  // Deterministic v1 ranking constants (locked)
const RANK_W = Object.freeze({ vert: 60, mr: 20, sd: 1.2 });
const CONF_MULT = Object.freeze({ high: 1.00, mod: 0.90, low: 0.78 });



  const $ = (id) => document.getElementById(id);


  // Number formatting helpers (defensive)
  const _NF0 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
  const _NF1 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  const _NF2 = new Intl.NumberFormat(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  function _num(x){
    const v = (x === null || x === undefined || x === "") ? NaN : Number(x);
    return Number.isFinite(v) ? v : null;
  }
  function fmt0(x){ const v = _num(x); return v === null ? "â€”" : _NF0.format(v); }
  function fmt1(x){ const v = _num(x); return v === null ? "â€”" : _NF1.format(v); }
  function fmt2(x){ const v = _num(x); return v === null ? "â€”" : _NF2.format(v); }


  function fmtDateShort(iso){
    const d = new Date(iso + "T00:00:00");
    return d.toLocaleDateString(undefined, { month:"short", day:"2-digit" });
  }

  function renderLastSessionCell(agg){
    if (!agg) return "â€”";
    const top = String(agg.lastLabel || "â€”");
    const sub = agg.last ? fmtDateShort(agg.last) : "";
    const title = escapeHTML(top + (sub ? ("\n" + sub) : ""));
    return `<div class="lsTop" title="${title}">${escapeHTML(top)}</div>` + (sub ? `<div class="lsSub">${escapeHTML(sub)}</div>` : "");
  }


  function escapeHTML(str){
    return String(str ?? "").replace(/[&<>"']/g, (ch) => (
      ch === "&" ? "&amp;" :
      ch === "<" ? "&lt;" :
      ch === ">" ? "&gt;" :
      ch === '"' ? "&quot;" : "&#39;"
    ));
  }





function summarizeImportErrors(errs, maxLines){
    const max = maxLines ?? 6;
    const buckets = new Map();
    for (const raw of (errs || [])){
      const s = String(raw || "");
      // normalize noisy counters so we can group similar messages
      const key = s
        .replace(/block\s+\d+/gi, "block #")
        .replace(/\bT\d+\b/g, "T#")
        .replace(/\bR\d+\b/g, "R#");
      buckets.set(key, (buckets.get(key) || 0) + 1);
    }
    const arr = Array.from(buckets.entries()).map(([msg, count]) => ({ msg, count }));
    arr.sort((a,b) => b.count - a.count);
    const lines = arr.slice(0, max).map(o => (o.count > 1 ? `(${o.count}Ã—) ${o.msg}` : o.msg));
    return { lines, more: Math.max(0, arr.length - max), groups: arr.length, total: (errs || []).length };
  }

  function renderImportErrorBox(errs){
    const sum = summarizeImportErrors(errs, 6);
    let html = `<div class="warnBox"><b>Import notes</b><br/>${sum.lines.map(e => escapeHTML(e)).join("<br/>")}`;
    if (sum.more > 0){
      html += `<br/><span class="muted">â€¦and ${sum.more} more types (${sum.total} entries)</span>`;
    }
    html += `</div>`;
    return html;
  }



// Trend popover (click Trend mini)
let _trendPopOpen = false;

function ensureTrendPopoverUI(){
  let ov = document.getElementById("trendPop");
  if (ov) return ov;
  ov = document.createElement("div");
  ov.id = "trendPop";
  ov.innerHTML = `
    <div class="trendCard" role="dialog" aria-modal="false" aria-label="Trend">
      <div class="trendHead">
        <div class="trendTitle">Trend</div>
        <button class="trendClose" id="btnTrendClose" type="button" aria-label="Close">Ã—</button>
      </div>
      <div class="trendRow">
        <div class="trendIcon neutral" id="trendIcon">â€”</div>
        <svg class="trendSpark" id="trendSpark" viewBox="0 0 240 56" preserveAspectRatio="none"></svg>
      </div>
      <div class="trendText" id="trendText"></div>
    </div>
  `;
  document.body.appendChild(ov);

  // Click outside to close
  ov.addEventListener("pointerdown", (e) => {
    if (e.target === ov) hideTrendPopover();
  });
  ov.querySelector("#btnTrendClose").addEventListener("click", hideTrendPopover);
  return ov;
}

function hideTrendPopover(){
  const ov = document.getElementById("trendPop");
  if (!ov) return;
  ov.classList.remove("show");
  _trendPopOpen = false;
}

function _sparkPath(values){
  const w = 240, h = 56, pad = 6;
  if (!values || values.length < 2) return { d:"", dot:null };

  // Lower vert is better â†’ map min (best) toward top
  const minV = Math.min(...values);
  const maxV = Math.max(...values);
  const span = (maxV - minV) || 1e-9;

  const xs = values.map((_,i) => pad + (i * (w - pad*2) / (values.length - 1)));
  const ys = values.map(v => pad + ((v - minV) / span) * (h - pad*2));

  let d = `M ${xs[0].toFixed(2)} ${ys[0].toFixed(2)}`;
  for (let i=1;i<values.length;i++){
    d += ` L ${xs[i].toFixed(2)} ${ys[i].toFixed(2)}`;
  }
  return { d, dot: { x: xs[xs.length-1], y: ys[ys.length-1] } };
}

function openTrendPopover(barrelId, anchorEl){
  const ov = ensureTrendPopoverUI();
  const card = ov.querySelector(".trendCard");
  const icon = ov.querySelector("#trendIcon");
  const svg = ov.querySelector("#trendSpark");
  const txt = ov.querySelector("#trendText");

  // Determine state
  const agg = getAggCached ? getAggCached(barrelId) : (aggregate ? aggregate(barrelId) : null);
  const trend = agg?.trend || "flat";
  const trendLabel = trend === "up" ? "Up" : trend === "down" ? "Down" : "Neutral";

  // Icon styling
  icon.classList.remove("good","bad","neutral");
  if (trend === "up") icon.classList.add("good");
  else if (trend === "down") icon.classList.add("bad");
  else icon.classList.add("neutral");
  icon.textContent = trend === "up" ? "â–²" : trend === "down" ? "â–¼" : "â€¢";

  // Build series (use form window sessions; fall back to all sessions)
  const win = (typeof formWindowSessions === "function") ? formWindowSessions(barrelId) : [];
  const seriesSrc = (win && win.length) ? win : (typeof sessionsForBarrel === "function" ? sessionsForBarrel(barrelId) : []);
  const series = seriesSrc
    .slice(0, 8)
    .slice()
    .reverse()
    .filter(s => Number.isFinite(Number(s.vert)))
    .map(s => Number(s.vert));

  const sp = _sparkPath(series);
  svg.innerHTML = "";

  if (!sp.d){
    // No chart yet
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x","8"); t.setAttribute("y","32");
    t.setAttribute("fill","rgba(148,163,184,.85)");
    t.setAttribute("font-size","12");
    t.textContent = "Need 2+ sessions with Vert in the form window.";
    svg.appendChild(t);
    txt.textContent = `Trend: ${trendLabel}.`;
  } else {
    const p = document.createElementNS("http://www.w3.org/2000/svg","path");
    p.setAttribute("d", sp.d);
    p.setAttribute("class", `sparkPath ${trend === "up" ? "good" : trend === "down" ? "bad" : "neutral"}`);
    svg.appendChild(p);

    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", sp.dot.x.toFixed(2));
    c.setAttribute("cy", sp.dot.y.toFixed(2));
    c.setAttribute("r","4.2");
    c.setAttribute("class","sparkDot");
    svg.appendChild(c);

    const delta = (series.length >= 2) ? (series[series.length-1] - series[0]) : 0;
    const deltaTxt = (series.length >= 2)
      ? `Î”Vert ${(delta>0?"+":"")}${fmt2(delta)} MOA (older â†’ newer)`
      : "";
    txt.textContent = `Trend: ${trendLabel}${deltaTxt ? " â€¢ " + deltaTxt : ""}.`;
  }

  // Position near anchor (prefer below; flip if needed)
  const r = anchorEl?.getBoundingClientRect?.() || { left: 20, top: 20, right: 20, bottom: 20, width: 0, height: 0 };
  ov.classList.add("show");
  _trendPopOpen = true;

  // Ensure dimensions after display
  const cw = card.offsetWidth || 340;
  const ch = card.offsetHeight || 160;

  const margin = 12;
  let left = Math.round(r.left + (r.width/2) - (cw/2));
  left = Math.max(margin, Math.min(left, window.innerWidth - cw - margin));

  let top = Math.round(r.bottom + 10);
  if (top + ch > window.innerHeight - margin){
    top = Math.round(r.top - ch - 10);
  }
  top = Math.max(margin, Math.min(top, window.innerHeight - ch - margin));

  card.style.left = left + "px";
  card.style.top = top + "px";
}

function renderImportNotes(notes){
    const arr = (notes || []);
    const max = 30;
    const shown = arr.slice(0, max);
    const lines = shown.map(n => "â€¢ " + escapeHTML(n)).join("<br/>");
    const more = arr.length - shown.length;
    return lines + (more > 0 ? `<br/><span class="muted">â€¦and ${more} more</span>` : "");
  }

  function renderImportDiagnostics(diags){
    const arr = (diags || []).slice().reverse(); // newest first
    const max = 10;
    const shown = arr.slice(0, max);
    const lines = shown.map(d => {
      const file = escapeHTML(d.file || "file");
      const blk = (d.block != null) ? ` block ${d.block}` : "";
      const shots = (d.shotsParsed != null) ? `${d.shotsParsed} shots` : "";
      const unit = d.unit ? ` (${escapeHTML(d.unit)})` : "";
      const map = d.map ? ` â†’ <b>${escapeHTML(d.map)}</b>` : "";
      const warn = (d.warnings && d.warnings.length) ? ` Â· <span style="color:#fde68a">${escapeHTML(d.warnings.join("; "))}</span>` : "";
      const sample = (d.sample && d.sample.length) ? `<div style="margin-top:6px;color:var(--muted);">sample: <span style="font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">${escapeHTML(d.sample.join(" | "))}</span></div>` : "";
      return `<div style="margin-bottom:10px;"><b>${file}</b>${blk}: ${escapeHTML(shots)}${unit}${map}${warn}${sample}</div>`;
    }).join("");
    const more = (arr.length > max) ? `<div style="color:var(--muted);">(+${arr.length-max} more)</div>` : "";
    return lines + more;
  }






  function slugify(s){
    return String(s ?? "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g,"_")
      .replace(/^_+|_+$/g,"")
      .slice(0,60) || "file";
  }


  function downloadText(filename, text, mime){
    const blob = new Blob([text], { type: mime || "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }

  function buildExportPayload(){
    const now = new Date();
    return {
      app: APP.name,
      tool_version: APP_VERSION_TAG,
      export_version: "v3",
      schema_version: SCHEMA_VERSION,
      created_at: now.toISOString(),
      state: {
        barrels: state.barrels || [],
        sessions: state.sessions || [],
        settings: {
          windowRounds: state.windowRounds,
          minConfidence: state.minConf,
          showSighters: state.showSighters
        },
        ui: state.ui || null,
        import_diagnostics: state.importDiagnostics || null
      }
    };
  }


  function buildSupportBundle(){
    const payload = buildExportPayload();
    return {
      app: payload.app,
      tool_version: payload.tool_version,
      export_version: "support_v1",
      schema_version: payload.schema_version,
      created_at: payload.created_at,
      env: {
        userAgent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform
      },
      diagnostics: {
        ui: state.ui || null,
        import_diagnostics: state.importDiagnostics || null
      },
      state: payload.state
    };
  }

function migrateExportPayload(payload){
    // Accept older exports and normalize to the current in-memory shape.
    const p = payload && typeof payload === "object" ? payload : {};
    const sv = (p.schema_version != null) ? Number(p.schema_version) : null;
    const ev = String(p.export_version || "v1");

    // Base validation
    if (!p.state || typeof p.state !== "object") return p;

    // v1 -> v2: settings key normalization (minConfidence -> minConf in state)
    // and ensure required top-level fields exist.
    if (sv == null && ev === "v1"){
      p.schema_version = 1;
    }

    // Normalize settings
    const set = p.state.settings || {};
    if (set && typeof set === "object"){
      // keep key for backwards compat, but normalize access later
      if (set.minConf == null && set.minConfidence != null) set.minConf = set.minConfidence;
    }

    // v2 -> v3: UI prefs (columns/layout) & import diagnostics (optional)
    if (Number(p.schema_version) <= 2){
      p.schema_version = 3;
    }


    // Normalize barrels
    if (Array.isArray(p.state.barrels)){
      p.state.barrels = p.state.barrels
        .filter(b => b && b.id)
        .map(b => ({
          id: String(b.id),
          display: b.display != null ? String(b.display) : String(b.id),
          twist: b.twist != null ? String(b.twist) : undefined,
          startRounds: Math.max(0, Math.floor(toNum(b.startRounds) ?? 0))
        }));
    }

    // Normalize sessions
    if (Array.isArray(p.state.sessions)){
      p.state.sessions = p.state.sessions
        .filter(s => s && s.id && s.barrelId)
        .map(s => ({
          id: String(s.id),
          barrelId: String(s.barrelId),
          date: s.date != null ? String(s.date) : null,
          label: s.label != null ? String(s.label) : "",
          vert: toNum(s.vert) ?? null,
          mr: toNum(s.mr) ?? null,
          sd: toNum(s.sd) ?? null,
          confidence: (s.confidence === "high" || s.confidence === "mod" || s.confidence === "low") ? s.confidence : "low",
          shotsUsed: (s.shotsUsed != null ? Number(s.shotsUsed) : (s.shotsUsed===0?0:null)),
          shotsTotal: (s.shotsTotal != null ? Number(s.shotsTotal) : (s.shotsTotal===0?0:null)),
          sighters: !!s.sighters,
          sourceFile: s.sourceFile != null ? String(s.sourceFile) : "",
          distanceYd: (s.distanceYd != null ? Number(s.distanceYd) : null),
          chronoShots: (s.chronoShots != null ? Number(s.chronoShots) : null),
          chronoSource: s.chronoSource != null ? String(s.chronoSource) : "",
        }));
    }

    return p;
  }


  function wireDropZone(el, onFiles){
    if (!el) return;
    const setDrag = (v) => el.classList.toggle("drag", !!v);
    el.addEventListener("dragover", (e) => { e.preventDefault(); setDrag(true); });
    el.addEventListener("dragleave", () => setDrag(false));
    el.addEventListener("drop", async (e) => {
      e.preventDefault(); setDrag(false);
      const files = [...(e.dataTransfer?.files || [])].filter(f => f && f.size);
      if (files.length) await onFiles(files);
    });
  }


  function extractDistanceYdFromShotMarker(text){
    const raw = String(text||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const scanMax = Math.min(raw.length, 120);
    // Look for explicit distance lines/fields in metadata/header area
    // Examples we try to catch: "Distance,1000", "distance: 1000 yd", "Range 1000y"
    const rx = /(?:distance|range|yard|yards|yd)\s*[:=,\t ]\s*(\d{2,4})\s*(?:yd|yards|y)?/i;
    for (let i=0;i<scanMax;i++){
      const line = String(raw[i]||"").trim();
      if (!line) continue;
      const m = line.match(rx);
      if (m){
        const yd = parseInt(m[1],10);
        if (yd >= 25 && yd <= 2000) return yd;
      }
      // Sometimes it's "1000 yd" without a label but near the top
      const m2 = line.match(/\b(\d{3,4})\s*(?:yd|yards|y)\b/i);
      if (m2){
        const yd = parseInt(m2[1],10);
        if (yd >= 25 && yd <= 2000) return yd;
      }
    }
    return null;
  }

function parseCSV(text){
    // Robust-ish CSV parser for SM/Garmin-style exports:
    // - Skips metadata lines above the real header
    // - Handles repeated header lines (skips them)
    // - Handles a leading empty column (common when lines start with a comma)
    const rawLines = String(text || "").replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const lines = rawLines.filter(l => l != null && l.trim().length);

    const splitLine = (line) => {
      const out = [];
      let cur = "", inQ = false;
      for (let i=0;i<line.length;i++){
        const c = line[i];
        if (c === '"'){
          if (inQ && line[i+1] === '"'){ cur += '"'; i++; continue; }
          inQ = !inQ; continue;
        }
        if (c === "," && !inQ){ out.push(cur); cur = ""; continue; }
        cur += c;
      }
      out.push(cur);
      return out.map(s => String(s ?? "").trim());
    };

    const headerScore = (cols) => {
      const nks = cols.map(normKey);
      const letterish = cols.filter(c => /[A-Za-z]/.test(String(c||""))).length;
      if (cols.length < 4 || letterish < Math.max(2, Math.floor(cols.length*0.3))) return 0;

      let s = 0;
      if (nks.includes("time")) s += 1;
      if (nks.some(k => ["x","xmm","horiz","horizontal","dx"].includes(k) || k.startsWith("xmm") || k.includes("xmm"))) s += 1;
      if (nks.some(k => ["y","ymm","vert","vertical","dy"].includes(k) || k.startsWith("ymm") || k.includes("ymm"))) s += 1;
      if (nks.some(k => ["v","vfps","vel","velocity","fps","muzzlevelocity"].includes(k) || k.includes("fps") || k.includes("velocity"))) s += 1;
      return s;
    };

    // Find best header within the first ~80 non-empty lines
    let headerIdx = 0;
    let best = 0;
    const scanMax = Math.min(lines.length, 80);
    for (let i=0;i<scanMax;i++){
      const cols = splitLine(lines[i]);
      const sc = headerScore(cols);
      if (sc > best){
        best = sc;
        headerIdx = i;
      }
      // early stop if we found a strong header
      if (best >= 3) break;
    }

    const rawHeaders = splitLine(lines[headerIdx]).map(h => h.replace(/^\uFEFF/,""));
    // If the export starts each line with a comma, the first header will be "" â€” drop it.
    const dropFirst = rawHeaders.length && rawHeaders[0] === "";
    const headers = dropFirst ? rawHeaders.slice(1) : rawHeaders;

    const rows = [];
    for (let i=headerIdx+1;i<lines.length;i++){
      const cols0 = splitLine(lines[i]);
      // Skip repeated headers / section headers
      if (headerScore(cols0) >= best && i > headerIdx) continue;

      const cols = dropFirst ? cols0.slice(1) : cols0;
      if (!cols.length) continue;

      const obj = {};
      for (let j=0;j<headers.length;j++){
        obj[headers[j]] = (cols[j] ?? "");
      }
      rows.push(obj);
    }
    return { headers, rows };
  }

  // ShotMarker "shotslog" exports can contain multiple target blocks (sessions/strings).
  // We split them into per-target groups so they can pair 1:1 with chrono files.

  // --- Robust Target/Relay detector for ShotMarker exports (R1/R2/R3 etc) ---
    // --- Robust Target/Relay detector for ShotMarker exports (prefers ~equal-size groups like 22-shot strings) ---
  function guessTargetColumn(headers, rows){
    headers = headers || [];
    rows = rows || [];
    if (!headers.length || !rows.length) return null;

    const norm = (x)=>String(x||"").trim().toLowerCase().replace(/[^a-z0-9]+/g," ").trim();
    const hnorm = headers.map(h=>norm(h));

    // Helper: median of numeric array
    const median = (arr)=>{
      if (!arr || !arr.length) return 0;
      const a = arr.slice().sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2) ? a[mid] : (a[mid-1]+a[mid])/2;
    };

    // Give a name-based bonus, but DO NOT early-return; we still validate by group-size behavior.
    const nameBonus = (hn)=>{
      let b=0;
      if (!hn) return 0;
      if (hn.includes("relay")) b += 18;
      if (hn.includes("string")) b += 16;
      if (hn.includes("series")) b += 10;
      if (hn.includes("target")) b += 12;
      if (hn.includes("bull")) b += 10;
      if (hn.includes("stage")) b += 8;
      if (hn.includes("match")) b += 4;
      if (hn.includes("round")) b += 4;
      return b;
    };

    // Value patterns we like
    const rxR  = /^R\s*\d+$/i;                  // R1, R2...
    const rxT  = /^T\s*\d+$/i;                  // T1...
    const rxTT = /^TT\s*\d+(?:[-_ ]\d+)?$/i;    // TT9-218 etc
    const rxNum= /^\d+$/;

    // Avoid obvious non-group columns
    const badName = (hn)=> (
      hn === "x" || hn === "y" || hn.includes("x mm") || hn.includes("y mm") ||
      hn.includes("time") || hn.includes("timestamp") || hn.includes("date") ||
      hn.includes("wind") || hn.includes("temp") || hn.includes("pressure") ||
      hn.includes("elev") || hn.includes("alt") || hn.includes("latitude") || hn.includes("longitude") ||
      hn.includes("shot") && (hn.includes("x") || hn.includes("y") || hn.includes("radius")) || hn.includes("score")
    );

    // Score a column by: (a) pattern strength of uniques, (b) group-size distribution (prefers ~equal groups like 22 shots),
    // (c) sane number of groups (not 66 unique IDs), (d) optional name hints.
    const scoreColumn = (colName, hn)=>{
      const sample = rows.slice(0, Math.min(rows.length, 800));
      const vals = [];
      for (const r of sample){
        const v = String((r && r[colName]) ?? "").trim();
        if (v) vals.push(v);
      }
      if (vals.length < 10) return -1;

      const uniq = Array.from(new Set(vals));
      const uN = uniq.length;
      if (uN < 2 || uN > 80) return -1;

      // Group sizes on full rows (not just sample)
      const counts = new Map();
      for (const r of rows){
        const v = String((r && r[colName]) ?? "").trim();
        if (!v) continue;
        counts.set(v, (counts.get(v) || 0) + 1);
      }
      const sizes = Array.from(counts.values());
      if (sizes.length < 2) return -1;

      const med = median(sizes);
      const mean = rows.length / Math.max(1, sizes.length);

      // Pattern score on unique values
      let hitsStrong = 0, hitsWeak = 0;
      for (const u of uniq){
        if (rxR.test(u)) hitsStrong += 4;
        else if (rxT.test(u) || rxTT.test(u)) hitsStrong += 3;
        else if (rxNum.test(u)) hitsWeak += 1;
      }
      const fracStrong = hitsStrong / Math.max(1, uniq.length*3); // normalize-ish

      // Penalize "ID-like" columns where most groups are tiny (e.g., shot index)
      let score = 0;
      score += nameBonus(hn);

      // Prefer fewer groups and larger median group size.
      score += Math.min(med, 50) * 2.2;     // median group size is king
      score += Math.min(mean, 50) * 0.8;
      score -= uN * 1.1;                    // too many unique groups is bad

      // Reward strong patterns (R1/R2 ideal)
      score += fracStrong * 40;

      // Hard penalties for nonsense splits
      if (med < 8) score -= 35;
      if (uN > rows.length / 3) score -= 45;        // e.g., ~1-3 shots per group
      if (uN > 30 && med < 12) score -= 25;

      // Extra bonus if it looks like Relay (R#) specifically
      const relayFrac = uniq.filter(u=>rxR.test(u)).length / Math.max(1, uniq.length);
      if (relayFrac > 0.6) score += 22;

      return score;
    };

    let bestCol = null;
    let bestScore = -1;

    for (let i=0;i<headers.length;i++){
      const col = headers[i];
      const hn = hnorm[i];
      if (!col) continue;
      if (badName(hn)) continue;
      const sc = scoreColumn(col, hn);
      if (sc > bestScore){
        bestScore = sc;
        bestCol = col;
      }
    }

    // Require a minimum confidence to avoid accidental splits
    if (bestScore >= 22) return bestCol;
    return null;
  }

function parseShotMarkerMulti(text, filename){
    const raw = String(text || "").replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

    const isSessionLine = (line) => /^[A-Z][a-z]{2}\s+\d{1,2}\s+\d{4},/.test(String(line||"").trim()) || /^\d{1,2}\/\d{1,2}\/\d{4},/.test(String(line||"").trim());

    // Reuse the same CSV splitting logic as parseCSV
    const splitLine = (line) => {
      const out = [];
      let cur = "", inQ = false;
      for (let i=0;i<line.length;i++){
        const c = line[i];
        if (c === '"'){
          if (inQ && line[i+1] === '"'){ cur += '"'; i++; continue; }
          inQ = !inQ; continue;
        }
        if (c === "," && !inQ){ out.push(cur); cur = ""; continue; }
        cur += c;
      }
      out.push(cur);
      return out.map(s => String(s ?? "").trim());
    };

    const headerScore = (cols) => {
      const nks = cols.map(normKey);
      const letterish = cols.filter(c => /[A-Za-z]/.test(String(c||""))).length;
      if (cols.length < 4 || letterish < Math.max(2, Math.floor(cols.length*0.3))) return 0;
      let s = 0;
      if (nks.includes("time")) s += 1;
      if (nks.some(k => ["x","xmm","horiz","horizontal","dx"].includes(k) || k.startsWith("xmm") || k.includes("xmm"))) s += 1;
      if (nks.some(k => ["y","ymm","vert","vertical","dy"].includes(k) || k.startsWith("ymm") || k.includes("ymm"))) s += 1;
      if (nks.some(k => ["v","vfps","vel","velocity","fps","muzzlevelocity"].includes(k) || k.includes("fps") || k.includes("velocity"))) s += 1;
      return s;
    };

    const blocks = [];
    let cur = null;

    for (let i=0;i<raw.length;i++){
      const line = raw[i];
      if (!line || !line.trim()) continue;

      if (isSessionLine(line)){
        if (cur) blocks.push(cur);
        cur = { sessionLine: line.trim(), headerLine: null, headers: null, rows: [] };
        continue;
      }

      if (!cur) continue;

      // Find header inside a session
      if (!cur.headerLine){
        const cols0 = splitLine(line);
        if (headerScore(cols0) >= 3){
          cur.headerLine = line;
          const rawHeaders = cols0.map(h => String(h||"").replace(/^\uFEFF/,""));
          const dropFirst = rawHeaders.length && rawHeaders[0] === "";
          cur.headers = (dropFirst ? rawHeaders.slice(1) : rawHeaders).map(h => h.trim()).filter(h => h.length);
        }
        continue;
      }

      // Data rows: often start with a leading comma (empty first col)
      if (line.trim().startsWith(",")){
        const cols0 = splitLine(line);
        const dropFirst = cols0.length && cols0[0] === "";
        const cols = dropFirst ? cols0.slice(1) : cols0;

        if (!cols.length) continue;

        // Map row
        const obj = {};
        for (let j=0;j<cur.headers.length;j++){
          obj[cur.headers[j]] = (cols[j] ?? "");
        }

        // Skip blank rows
        const xKey = findCol(cur.headers, ["x mm","xmm","x"]);
        const yKey = findCol(cur.headers, ["y mm","ymm","y"]);
        const idKey = findCol(cur.headers, ["id"]);
        const hasXY = (toNum(obj[xKey]) != null) || (toNum(obj[yKey]) != null);
        const hasId = String(obj[idKey] ?? "").trim().length > 0;
        if (!hasXY && !hasId) continue;

        // Skip repeated header rows
        if (headerScore(cols0) >= 3) continue;

        cur.rows.push(obj);
      }
    }
    if (cur) blocks.push(cur);



    // If we detected one or more session blocks, ShotMarker can still contain multiple targets within a block.
    // In that case, split rows by Target-like column so targets can pair 1:1 with chrono files.
    if (blocks.length){
      const expanded = [];
      for (const b of blocks){
        // ShotMarker Archive format: each session block IS a target/string already (e.g., 12/27/2025,R3,...)
        // Do NOT split these blocks again by Target-like columns.
        const isArchive = (/^[A-Z][a-z]{2}\s+\d{1,2}\s+\d{4},/.test(String(b.sessionLine||"").trim()) || /^\d{1,2}\/\d{1,2}\/\d{4},/.test(String(b.sessionLine||"").trim())) && String(b.headerLine||"").trim().startsWith(",time");
        if (isArchive){
          const sCols = splitLine(b.sessionLine || "");
          const lab = (sCols[1] || "").trim() || "Session";
          expanded.push(Object.assign({}, b, { targetLabel: lab }));
          continue;
        }

        const headers = b.headers || [];
        const rows = b.rows || [];
        const tKey = guessTargetColumn(headers, rows);
        if (!tKey || !rows.length){ expanded.push(b); continue; }

        const order = [];
        const map = new Map();
        for (const r of rows){
          const tv = String((r && r[tKey]) ?? "").trim();
          // If target field is empty, treat it as part of the first bucket
          const key = tv || "__UNSPEC__";
          if (!map.has(key)){ map.set(key, []); order.push(key); }
          map.get(key).push(r);
        }

        // If we only have one real bucket, keep original block
        const real = order.filter(k => k !== "__UNSPEC__");
        if (real.length <= 1){
          expanded.push(b);
          continue;
        }

        for (const key of order){
          if (key === "__UNSPEC__") continue;
          expanded.push({
            sessionLine: b.sessionLine,
            headerLine: b.headerLine,
            headers: b.headers,
            rows: map.get(key) || [],
            targetLabel: key
          });
        }
      }
      // replace blocks contents
      blocks.length = 0;
      for (const b of expanded) blocks.push(b);
    }

// Fallback: if we didn't detect session blocks, treat as CSV.
    // If a Target column exists, split into N targets so pairing can be 1:1 with chrono files.
    if (!blocks.length){
      const parsed = parseCSV(text);
      const nice = filename?.replace(/\.[^.]+$/,"") || "ShotMarker";
      const headers = parsed.headers || [];
      const rows = parsed.rows || [];

      const tKey = guessTargetColumn(headers, rows);
      if (tKey){
        const order = [];
        const map = new Map();
        for (const r of rows){
          const tv = String((r && r[tKey]) ?? "").trim();
          if (!tv) continue;
          if (!map.has(tv)){ map.set(tv, []); order.push(tv); }
          map.get(tv).push(r);
        }
        if (order.length){
          return order.map(tv => ({
            sourceFile: filename,
            label: `${nice} â€” Target ${tv}`,
            headers,
            rows: map.get(tv) || [],
            targetLabel: tv
          }));
        }
      }

      return [{
        sourceFile: filename,
        label: nice,
        headers,
        rows,
      }];
    }
return blocks
  .filter(b => (b.rows || []).length)
  .map((b, idx) => {
    const nice = filename?.replace(/\.[^.]+$/,"") || "ShotMarker";
    const base = b.sessionLine || nice;
    const label = b.targetLabel ? `${base} â€” Target ${b.targetLabel} â€” ${nice}` : `${base} â€” ${nice}`;

    // Extract local timestamp from the session line when present:
    // Example: "Oct 11 2025, 08:19:43"
    let timeMs = null;
    const m = String(b.sessionLine||"").match(/([A-Z][a-z]{2})\s+(\d{1,2})\s+(20\d{2})(?:,\s*(\d{1,2}):(\d{2})(?::(\d{2}))?)?/);
    if (m){
      const mon = m[1], day = String(m[2]).padStart(2,"0"), yr = m[3];
      const months = {Jan:"01",Feb:"02",Mar:"03",Apr:"04",May:"05",Jun:"06",Jul:"07",Aug:"08",Sep:"09",Oct:"10",Nov:"11",Dec:"12"};
      const mm = months[mon] || "01";
      const hh = String(m[4] || "00").padStart(2,"0");
      const mi = String(m[5] || "00").padStart(2,"0");
      const ss = String(m[6] || "00").padStart(2,"0");
      timeMs = new Date(`${yr}-${mm}-${day}T${hh}:${mi}:${ss}`).getTime();
    }

    return {
      sourceFile: filename,
      label,
      timeMs,
      sessionLine: b.sessionLine || null,
      targetLabel: b.targetLabel || null,
      headers: b.headers || [],
      rows: b.rows || []
    };
  });
  }



  // Heuristic: determine whether a ShotMarker block is a SIGHTER-only target.
  // We keep this deterministic + conservative:
  // - If the session line/label/filename contains "sighter" -> true
  // - Else if there is an explicit Sighter/Type column AND ~all rows are marked sighter -> true
  // - Otherwise -> false
  function detectSightersFromShotMarkerBlock(block){
    const label = String(block?.label || "");
    const fileName = String(block?.fileName || block?.sourceFile || "");
    const sessionLine = String(block?.sessionLine || "");
    const hay = (label + " " + fileName + " " + sessionLine).toLowerCase();
    if (hay.includes("sighter")) return true;

    const headers = block?.headers || [];
    const rows = block?.rows || [];
    if (!headers.length || !rows.length) return false;

    const sCol = findCol(headers, ["sighter","sighters","is sighter","issighter","shot type","shottype","type"]);
    if (!sCol) return false;

    const truthy = (v) => {
      const s = String(v ?? "").trim().toLowerCase();
      if (!s) return false;
      return (s === "1" || s === "true" || s === "yes" || s === "y" || s === "s" || s === "sighter" || s === "sighters");
    };

    let marked = 0, seen = 0;
    for (const r of rows){
      const v = r?.[sCol];
      if (v == null || String(v).trim()==="") continue;
      seen++;
      if (truthy(v)) marked++;
      else{
        // also treat explicit "record" / "match" as not sighter
        const s = String(v).trim().toLowerCase();
        if (s.includes("record") || s.includes("match")) return false;
      }
    }
    if (seen < Math.max(3, Math.floor(rows.length*0.2))) return false;

    const ratio = marked / seen;
    return ratio >= 0.95;
  }




  // --- Minimal XLS (BIFF8) reader for Garmin-style chrono exports (.xls) ---
  // This is NOT a full Excel engine. It extracts the first worksheet as a simple table
  // and is tuned for small, single-sheet exports (like Garmin "Rifle_Bullet_*.xls").
  // It supports common cell types: NUMBER, RK, MULRK, LABELSST (via SST), and inline LABEL.

  // --- Robust XLS (BIFF8) reader for Garmin-style chrono exports (.xls) ---
  // Purpose-built: extracts FIRST worksheet into a simple table of strings.
  // Supports the Garmin chrono exports we've seen (strings stored via SST + LABELSST).
  // Not a full Excel engine; no formulas/styles.
  function parseXLS(arrayBuffer){
    const u8 = new Uint8Array(arrayBuffer);
    const wbU8 = oleExtractStream(u8, ["Workbook","Book"]);
    if (!wbU8) throw new Error("XLS: couldn't find Workbook stream");
    const view = new DataView(wbU8.buffer, wbU8.byteOffset, wbU8.byteLength);

    function readRecAt(off){
      if (off + 4 > view.byteLength) return null;
      const rt = view.getUint16(off, true);
      const rl = view.getUint16(off+2, true);
      const ro = off + 4;
      const no = ro + rl;
      if (no > view.byteLength) return null;
      return { rt, rl, ro, no };
    }

    // Parse SST (Shared String Table)
    function readXLUnicodeStringAt(o){
      const cch = view.getUint16(o, true); o += 2;
      const flags = view.getUint8(o); o += 1;
      const fHighByte = (flags & 0x01) !== 0;
      const fRichSt = (flags & 0x08) !== 0;
      const fExtSt  = (flags & 0x04) !== 0;
      let cRun = 0, cbExtRst = 0;
      if (fRichSt){ cRun = view.getUint16(o, true); o += 2; }
      if (fExtSt){ cbExtRst = view.getUint32(o, true); o += 4; }
      let str = "";
      if (cch > 0){
        if (fHighByte){
          const bytes = new Uint8Array(wbU8.buffer, wbU8.byteOffset + o, cch*2);
          str = new TextDecoder("utf-16le").decode(bytes);
          o += cch*2;
        }else{
          const bytes = new Uint8Array(wbU8.buffer, wbU8.byteOffset + o, cch);
          str = new TextDecoder("latin1").decode(bytes);
          o += cch;
        }
      }
      if (fRichSt) o += cRun * 4;
      if (fExtSt)  o += cbExtRst;
      return { str, next: o };
    }

    let sst = [];
    let sheetOffset = null;

    // First pass: find BOUNDSHEET and SST in globals stream
    let off = 0;
    while (true){
      const r = readRecAt(off);
      if (!r) break;

      if (r.rt === 0x0085 && r.rl >= 6 && sheetOffset == null){
        sheetOffset = view.getUint32(r.ro + 0, true);
      }
      if (r.rt === 0x00FC && r.rl >= 8){
        // SST payload begins at r.ro
        let o = r.ro;
        const total = view.getUint32(o, true); o += 4;
        const unique = view.getUint32(o, true); o += 4;
        sst = [];
        for (let i=0; i<unique; i++){
          const res = readXLUnicodeStringAt(o);
          sst.push(res.str);
          o = res.next;
          if (o >= view.byteLength) break;
        }
      }

      off = r.no;
      if (off >= view.byteLength) break;
    }

    if (sheetOffset == null){
      // fallback: scan for first worksheet BOF and treat that as sheet start
      off = 0;
      while (true){
        const r = readRecAt(off);
        if (!r) break;
        if (r.rt === 0x0809 && r.rl >= 4){
          const bofType = view.getUint16(r.ro + 2, true);
          if (bofType === 0x0010){ sheetOffset = off; break; }
        }
        off = r.no;
      }
    }
    if (sheetOffset == null) throw new Error("XLS: couldn't locate worksheet");

    // Second pass: parse worksheet cells
    const cells = new Map(); // "r,c" => value string
    const key = (r,c)=> r + "," + c;
    let maxR = 0, maxC = 0;

    off = sheetOffset;
    while (true){
      const r = readRecAt(off);
      if (!r) break;
      const t = r.rt;

      if (t === 0x000A){ break; } // EOF ends sheet

      // LABELSST: row(2), col(2), xf(2), sstIndex(4)
      if (t === 0x00FD && r.rl >= 10){
        const row = view.getUint16(r.ro + 0, true);
        const col = view.getUint16(r.ro + 2, true);
        const sstIdx = view.getUint32(r.ro + 6, true);
        const val = (sstIdx < sst.length) ? sst[sstIdx] : "";
        cells.set(key(row,col), val);
        if (row > maxR) maxR = row;
        if (col > maxC) maxC = col;
      }

      // LABEL (inline string): row, col, xf, cch(2), bytes
      if (t === 0x0204 && r.rl >= 8){
        const row = view.getUint16(r.ro + 0, true);
        const col = view.getUint16(r.ro + 2, true);
        const cch = view.getUint16(r.ro + 6, true);
        const bytes = new Uint8Array(wbU8.buffer, wbU8.byteOffset + r.ro + 8, cch);
        const val = new TextDecoder("latin1").decode(bytes);
        cells.set(key(row,col), val);
        if (row > maxR) maxR = row;
        if (col > maxC) maxC = col;
      }

      off = r.no;
      if (off >= view.byteLength) break;
    }

    // Build table
    const table = [];
    for (let r=0; r<=maxR; r++){
      const row = [];
      for (let c=0; c<=maxC; c++){
        row.push(cells.get(key(r,c)) ?? "");
      }
      table.push(row);
    }

    // Trim empty trailing rows
    while (table.length && table[table.length-1].every(v => String(v||"").trim()==="")) table.pop();
    // Trim empty trailing cols
    if (table.length){
      let cols = table[0].length;
      while (cols>0){
        let empty=true;
        for (let r=0; r<table.length; r++){
          if (String(table[r][cols-1]||"").trim()!==""){ empty=false; break; }
        }
        if (!empty) break;
        cols--;
      }
      table.forEach(r=> r.length=cols);
    }

    // Convert to {headers, rows} like parseCSV
    const headerRow = table[0] || [];
    const headers = headerRow.map((h,ci) => {
      const s = String(h||"").trim();
      return s.length ? s : ("COL_" + (ci+1));
    });
    const rows = [];
    for (let i=1; i<table.length; i++){
      const r = table[i];
      const obj = {};
      for (let c=0; c<headers.length; c++){
        obj[headers[c]] = (r[c] ?? "");
      }
      const hasAny = Object.values(obj).some(v => String(v).trim().length);
      if (hasAny) rows.push(obj);
    }
    return { headers, rows };
  }

// --- Minimal XLSX reader (offline) ---
// Supports typical Garmin/chrono single-sheet exports.
// Strategy:
//  - XLSX is a ZIP. We read entries and inflate (deflate) using DecompressionStream when available.
//  - Parse sharedStrings.xml (if present) and first worksheet XML.
//  - Convert the sheet into a simple table -> {headers, rows}.
//
// If the browser doesn't support DecompressionStream('deflate-raw'), we fall back to a clear UX message
// telling users to export CSV.
async function parseXLSX(arrayBuffer){
  const u8 = new Uint8Array(arrayBuffer);

  // ---- ZIP helpers (central directory scan) ----
  const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);

  function u32(o){ return dv.getUint32(o, true); }
  function u16(o){ return dv.getUint16(o, true); }

  function findEOCD(){
    // EOCD signature 0x06054b50
    // Search backwards from end, within 64KB
    const maxBack = Math.min(u8.byteLength, 22 + 0xFFFF);
    for (let i=u8.byteLength-22; i>=u8.byteLength-maxBack; i--){
      if (i < 0) break;
      if (u32(i) === 0x06054b50) return i;
    }
    return -1;
  }

  async function inflateRaw(comp){
    // comp: Uint8Array
    if (typeof DecompressionStream !== "function"){
      throw new Error("XLSX: This browser can't inflate ZIP data offline. Export CSV instead.");
    }
    // ZIP uses raw deflate stream (no zlib header)
    const ds = new DecompressionStream("deflate-raw");
    const blob = new Blob([comp]);
    const stream = blob.stream().pipeThrough(ds);
    const ab = await new Response(stream).arrayBuffer();
    return new Uint8Array(ab);
  }

  async function getZipEntries(){
    const eocd = findEOCD();
    if (eocd < 0) throw new Error("XLSX: Invalid ZIP (EOCD not found). Export CSV instead.");

    const cdSize = u32(eocd + 12);
    const cdOff  = u32(eocd + 16);
    if (cdOff + cdSize > u8.byteLength) throw new Error("XLSX: Invalid ZIP directory. Export CSV instead.");

    const entries = new Map();

    let p = cdOff;
    const end = cdOff + cdSize;
    while (p + 46 <= end){
      if (u32(p) !== 0x02014b50) break; // central file header
      const compMethod = u16(p + 10);
      const compSize   = u32(p + 20);
      const uncompSize = u32(p + 24);
      const nameLen    = u16(p + 28);
      const extraLen   = u16(p + 30);
      const cmtLen     = u16(p + 32);
      const lho        = u32(p + 42);
      const nameBytes  = u8.slice(p + 46, p + 46 + nameLen);
      const name = new TextDecoder("utf-8").decode(nameBytes);

      entries.set(name, { name, compMethod, compSize, uncompSize, lho });

      p = p + 46 + nameLen + extraLen + cmtLen;
    }
    return entries;
  }

  async function readEntry(entries, name){
    const e = entries.get(name);
    if (!e) return null;

    // local header
    const p = e.lho;
    if (p + 30 > u8.byteLength) throw new Error("XLSX: Corrupt local header. Export CSV instead.");
    if (u32(p) !== 0x04034b50) throw new Error("XLSX: Corrupt local header sig. Export CSV instead.");
    const nameLen  = u16(p + 26);
    const extraLen = u16(p + 28);
    const dataOff  = p + 30 + nameLen + extraLen;

    const comp = u8.slice(dataOff, dataOff + e.compSize);

    if (e.compMethod === 0){ // stored
      return comp;
    }
    if (e.compMethod === 8){ // deflate
      return await inflateRaw(comp);
    }
    throw new Error("XLSX: Unsupported ZIP compression method " + e.compMethod + ". Export CSV instead.");
  }

  const entries = await getZipEntries();

  // Try to locate first worksheet (sheet1.xml preferred)
  let sheetPath = "xl/worksheets/sheet1.xml";
  if (!entries.has(sheetPath)){
    // fallback: find first worksheet file
    for (const k of entries.keys()){
      if (/^xl\/worksheets\/sheet\d+\.xml$/i.test(k)){ sheetPath = k; break; }
    }
  }

  const sharedPath = "xl/sharedStrings.xml";
  const sheetU8 = await readEntry(entries, sheetPath);
  if (!sheetU8) throw new Error("XLSX: Couldn't find worksheet XML. Export CSV instead.");

  const sheetXML = new TextDecoder("utf-8").decode(sheetU8);

  let shared = [];
  const sharedU8 = entries.has(sharedPath) ? await readEntry(entries, sharedPath) : null;
  if (sharedU8){
    const sharedXML = new TextDecoder("utf-8").decode(sharedU8);
    const doc = new DOMParser().parseFromString(sharedXML, "application/xml");
    const sis = [...doc.getElementsByTagName("si")];
    shared = sis.map(si => {
      // strings may be split into multiple <t>
      const ts = [...si.getElementsByTagName("t")].map(t => t.textContent || "");
      return ts.join("");
    });
  }

  const sdoc = new DOMParser().parseFromString(sheetXML, "application/xml");
  const cells = [...sdoc.getElementsByTagName("c")];

  function colToIndex(col){
    // A -> 0, B -> 1, Z -> 25, AA -> 26...
    let n = 0;
    for (let i=0;i<col.length;i++){
      n = n*26 + (col.charCodeAt(i) - 64);
    }
    return n - 1;
  }

  function parseRef(ref){
    const m = String(ref||"").match(/^([A-Z]+)(\d+)$/i);
    if (!m) return null;
    return { c: colToIndex(m[1].toUpperCase()), r: parseInt(m[2],10)-1 };
  }

  const grid = new Map(); // "r,c" => string
  let maxR = 0, maxC = 0;

  for (const c of cells){
    const ref = c.getAttribute("r");
    const rc = parseRef(ref);
    if (!rc) continue;
    const t = c.getAttribute("t") || "";
    let v = "";

    if (t === "s"){
      const vv = c.getElementsByTagName("v")[0]?.textContent;
      const idx = parseInt(vv || "0", 10);
      v = (idx >= 0 && idx < shared.length) ? shared[idx] : "";
    }else if (t === "inlineStr"){
      const ts = [...c.getElementsByTagName("t")].map(x => x.textContent || "");
      v = ts.join("");
    }else{
      // numbers / general
      v = c.getElementsByTagName("v")[0]?.textContent || "";
    }

    const key = rc.r + "," + rc.c;
    grid.set(key, v);

    if (rc.r > maxR) maxR = rc.r;
    if (rc.c > maxC) maxC = rc.c;
  }

  // Build table
  const table = [];
  for (let r=0; r<=maxR; r++){
    const row = [];
    for (let c=0; c<=maxC; c++){
      row.push(grid.get(r + "," + c) ?? "");
    }
    table.push(row);
  }

  // Trim empty trailing rows
  while (table.length && table[table.length-1].every(v => String(v||"").trim()==="")) table.pop();
  // Trim empty trailing cols
  if (table.length){
    let cols = table[0].length;
    while (cols>0){
      let empty=true;
      for (let r=0; r<table.length; r++){
        if (String(table[r][cols-1]||"").trim()!==""){ empty=false; break; }
      }
      if (!empty) break;
      cols--;
    }
    table.forEach(r=> r.length=cols);
  }

  // Convert to {headers, rows} (mirror parseXLS)
  const headerRow = table[0] || [];
  const headers = headerRow.map((h,ci) => {
    const s = String(h||"").trim();
    return s.length ? s : ("COL_" + (ci+1));
  });

  const rows = [];
  for (let i=1; i<table.length; i++){
    const rr = table[i];
    const obj = {};
    for (let c=0; c<headers.length; c++){
      obj[headers[c]] = (rr[c] ?? "");
    }
    const hasAny = Object.values(obj).some(v => String(v).trim().length);
    if (hasAny) rows.push(obj);
  }
  return { headers, rows };
}



  function decodeRK(rk){
    // RK: lowest 2 bits are flags.
    const fX100 = (rk & 0x01) !== 0;
    const fInt  = (rk & 0x02) !== 0;
    let val;
    if (fInt){
      // signed 30-bit int in high bits
      val = (rk & 0xFFFFFFFC) >> 2;
      // sign extend
      if (val & 0x20000000) val = val - 0x40000000;
    }else{
      // 30-bit IEEE 754 (high) -> double; build 8 bytes
      const hi = rk & 0xFFFFFFFC;
      const buf = new ArrayBuffer(8);
      const dv = new DataView(buf);
      dv.setUint32(4, hi, true);
      dv.setUint32(0, 0, true);
      val = dv.getFloat64(0, true);
    }
    return fX100 ? (val / 100) : val;
  }

  function oleExtractStream(u8, names){
    // Very small OLE2 reader enough to extract a named stream.
    const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
    // magic D0 CF 11 E0 A1 B1 1A E1
    if (dv.getUint32(0, false) !== 0xD0CF11E0) return null;

    const secShift = dv.getUint16(30, true);
    const miniShift = dv.getUint16(32, true);
    const secSize = 1 << secShift;
    const miniSize = 1 << miniShift;

    const numFATSectors = dv.getUint32(44, true);
    const firstDirSec = dv.getInt32(48, true);
    const miniCutoff = dv.getUint32(56, true);
    const firstMiniFATSec = dv.getInt32(60, true);
    const numMiniFATSectors = dv.getUint32(64, true);
    const firstDIFATSec = dv.getInt32(68, true);
    const numDIFATSectors = dv.getUint32(72, true);

    const END = -2, FREE = -1;

    function secOffset(sid){ return (sid + 1) * secSize; }

    // Build DIFAT
    const difat = [];
    // header DIFAT entries (109)
    let o=76;
    for (let i=0;i<109;i++){
      const sid = dv.getInt32(o + i*4, true);
      if (sid >= 0) difat.push(sid);
    }
    // DIFAT chain
    let next = firstDIFATSec;
    for (let n=0; n<numDIFATSectors && next>=0; n++){
      const base = secOffset(next);
      const dv2 = new DataView(u8.buffer, u8.byteOffset + base, secSize);
      for (let i=0;i<(secSize/4)-1;i++){
        const sid = dv2.getInt32(i*4, true);
        if (sid >= 0) difat.push(sid);
      }
      next = dv2.getInt32(secSize-4, true);
    }

    // Read FAT sectors
    const fat = [];
    for (const sid of difat){
      const base = secOffset(sid);
      const dvF = new DataView(u8.buffer, u8.byteOffset + base, secSize);
      for (let i=0;i<secSize/4;i++){
        fat.push(dvF.getInt32(i*4, true));
      }
    }

    function readChain(firstSid, size){
      if (firstSid < 0) return new Uint8Array(0);
      const out = new Uint8Array(size);
      let sid = firstSid;
      let pos=0;
      while (sid >= 0 && sid !== END && pos < size){
        const base = secOffset(sid);
        const chunk = Math.min(secSize, size - pos);
        out.set(new Uint8Array(u8.buffer, u8.byteOffset + base, chunk), pos);
        pos += chunk;
        sid = fat[sid];
      }
      return out;
    }

    // Directory stream
    // Directory size isn't in header; read a generous amount by following chain until END
    // We'll read up to 1MB max for safety.
    const dirChunks = [];
    let sid = firstDirSec;
    let safety=0;
    while (sid >= 0 && sid !== END && safety < 4096){
      dirChunks.push(new Uint8Array(u8.buffer, u8.byteOffset + secOffset(sid), secSize));
      sid = fat[sid];
      safety++;
    }
    const dirBytes = concatU8(dirChunks);
    const dirDV = new DataView(dirBytes.buffer, dirBytes.byteOffset, dirBytes.byteLength);

    // Root entry provides mini stream start
    function readDirEntry(i){
      const base = i*128;
      if (base+128 > dirBytes.byteLength) return null;
      const nameLen = dirDV.getUint16(base+64, true);
      let name = "";
      for (let j=0;j<nameLen/2-1;j++){
        name += String.fromCharCode(dirDV.getUint16(base + j*2, true));
      }
      const type = dirDV.getUint8(base+66);
      const startSid = dirDV.getInt32(base+116, true);
      const sizeLo = dirDV.getUint32(base+120, true);
      // sizeHi ignored
      return { name, type, startSid, size: sizeLo };
    }

    const entries = [];
    for (let i=0;i<dirBytes.byteLength/128;i++){
      const e = readDirEntry(i);
      if (e && e.name) entries.push(e);
    }

    const root = entries.find(e => e.type === 5) || entries[0];
    const miniStream = root ? readChain(root.startSid, root.size) : new Uint8Array(0);

    // MiniFAT
    let miniFat = [];
    if (numMiniFATSectors && firstMiniFATSec >= 0){
      const miniFatBytes = readChain(firstMiniFATSec, numMiniFATSectors * secSize);
      const dvM = new DataView(miniFatBytes.buffer, miniFatBytes.byteOffset, miniFatBytes.byteLength);
      for (let i=0;i<dvM.byteLength/4;i++){
        miniFat.push(dvM.getInt32(i*4, true));
      }
    }

    function readMiniChain(firstSid, size){
      const out = new Uint8Array(size);
      let sid = firstSid;
      let pos=0;
      const miniPerSec = secSize / miniSize;
      while (sid >= 0 && sid !== END && pos < size){
        const base = sid * miniSize;
        const chunk = Math.min(miniSize, size - pos);
        out.set(miniStream.slice(base, base + chunk), pos);
        pos += chunk;
        sid = miniFat[sid];
      }
      return out;
    }

    // Find desired stream
    const wantNames = (names||[]).map(n => String(n||"").toLowerCase());
    let want = entries.find(e => wantNames.includes(String(e.name||"").toLowerCase()));
    if (!want){
      // fallback: common variants
      want = entries.find(e => String(e.name||"").toLowerCase().includes("workbook")) ||
             entries.find(e => String(e.name||"").toLowerCase().includes("book"));
    }
    if (!want) return null;

    const data = (want.size < miniCutoff) ? readMiniChain(want.startSid, want.size)
                                          : readChain(want.startSid, want.size);
    return data;
  }

  function concatU8(chunks){
    let total=0;
    for (const c of chunks) total += c.byteLength;
    const out = new Uint8Array(total);
    let p=0;
    for (const c of chunks){ out.set(c, p); p += c.byteLength; }
    return out;
  }

function normKey(k){
    return String(k || "").toLowerCase().replace(/[^a-z0-9]+/g,"").trim();
  }

  function findCol(headers, candidates){
    const map = new Map(headers.map(h => [normKey(h), h]));
    for (const c of candidates){
      const nk = normKey(c);
      if (map.has(nk)) return map.get(nk);
    }
    // fuzzy contains
    for (const h of headers){
      const nk = normKey(h);
      if (candidates.some(c => nk.includes(normKey(c)))) return h;
    }
    return null;
  }

  function toNum(v){
    const x = parseFloat(String(v ?? "").replace(/[^0-9\.\-]+/g,""));
    return Number.isFinite(x) ? x : null;
  }

  function sampleRowPreview(parsed, headers, limit=8){
    try{
      const row0 = (parsed && parsed.rows && parsed.rows[0]) ? parsed.rows[0] : null;
      if (!row0) return [];
      if (Array.isArray(row0)){
        return row0.slice(0, limit).map(v => String(v ?? ""));
      }
      if (typeof row0 === "object"){
        // Prefer header order for readability
        const keys = (Array.isArray(headers) && headers.length) ? headers.filter(h => h in row0) : Object.keys(row0);
        return keys.slice(0, limit).map(k => `${k}: ${String(row0[k] ?? "")}`);
      }
      return [String(row0)];
    }catch(_e){
      return [];
    }
  }


  function inchesToMOA(inches, yd){
    const d = Math.max(1, yd || 1000);
    return inches * 100 / (1.047 * d);
  }

  function mean(arr){
    if (!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }

  function sampleSD(arr){
    if (arr.length < 2) return 0;
    const m = mean(arr);
    const v = arr.reduce((a,x)=>a + (x-m)*(x-m), 0) / (arr.length - 1);
    return Math.sqrt(v);
  }

  function parseDateFromFilename(name){
    const s = String(name || "");
    // 2025-10-11
    let m = s.match(/(20\d{2})[-_](\d{2})[-_](\d{2})/);
    if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    // 20251011
    m = s.match(/(20\d{2})(\d{2})(\d{2})/);
    if (m) return `${m[1]}-${m[2]}-${m[3]}`;
    return null;
  }


function parseDateTimeFromFilename(name){
  const s = String(name || "");
  // Common Garmin patterns:
  // - 2025-10-11_08-19-43
  // - 20251011_081943
  // - 2025_10_11 08_19_43
  let m = s.match(/(20\d{2})[-_](\d{2})[-_](\d{2}).*?(\d{2})[-_](\d{2})[-_](\d{2})/);
  if (m){
    const date = `${m[1]}-${m[2]}-${m[3]}`;
    const hh = m[4], mi = m[5], ss = m[6];
    const timeMs = new Date(`${date}T${hh}:${mi}:${ss}`).getTime();
    return { date, timeMs };
  }
  m = s.match(/(20\d{2})(\d{2})(\d{2}).*?(\d{2})(\d{2})(\d{2})/);
  if (m){
    const date = `${m[1]}-${m[2]}-${m[3]}`;
    const hh = m[4], mi = m[5], ss = m[6];
    const timeMs = new Date(`${date}T${hh}:${mi}:${ss}`).getTime();
    return { date, timeMs };
  }
  const d = parseDateFromFilename(s);
  if (d) return { date: d, timeMs: new Date(`${d}T00:00:00`).getTime() };
  return { date: null, timeMs: null };
}

  function suggestConfidence(shotsTotal, hasChrono, chronoShots){
    const n = shotsTotal || 0;
    const c = chronoShots || 0;
    // Confidence is "trust": sample size + chrono quality
    if (hasChrono){
      if (c > 0 && c < 15) return "low";
      if (n >= 20) return "high";
      if (n >= 15) return "mod";
      return "low";
    }
    // No chrono â†’ never "high"
    if (n >= 20) return "mod";
    if (n >= 15) return "mod";
    return "low";
  }

  function recomputeTargetMetrics(t, distanceYd){
    // expects t.shots: [{xIn,yIn}]
    const shots = t.shots || [];
    if (!shots.length) return { ...t, mr:0, vert:0, distanceYd };
    const ys = shots.map(s => s.yIn);
    const rs = shots.map(s => Math.sqrt((s.xIn||0)**2 + (s.yIn||0)**2));
    const mrIn = mean(rs);
    const vertIn = (Math.max(...ys) - Math.min(...ys));
    return {
      ...t,
      distanceYd,
      mr: inchesToMOA(mrIn, distanceYd),
      vert: inchesToMOA(vertIn, distanceYd)
    };
  }

  async function handleShotMarkerFiles(files, imp){
    imp.errors = imp.errors || [];
    imp.notes = Array.isArray(imp.notes) ? imp.notes : [];

    imp.status = "";
    // If a user accidentally drops chronograph exports here, auto-route them to the Chrono importer.
    const allFiles = Array.from(files || []);
    const xlsLike = allFiles.filter(f => /\.(xls|xlsx)$/i.test(f.name));
    if (xlsLike.length){
      try{
        await handleChronoFiles(xlsLike, imp);
        imp.notes.push(`Auto-detected ${xlsLike.length} chronograph file${xlsLike.length===1?"":"s"} dropped in ShotMarker; imported under Chrono.`);
      }catch(e){
        // fall through â€” ShotMarker will report its own errors
      }
    }
    let sighterTargets = 0;
    const csvFiles = files.filter(f => /\.csv$/i.test(f.name));
    if (!csvFiles.length){
      if (xlsLike && xlsLike.length){
        // User dropped only chrono exports here; we've already routed them to Chrono above.
        autoPair(imp);
        imp.status = imp.status || "Chrono files imported.";
        return;
      }
      imp.errors.push("ShotMarker: please use ShotMarker CSV exports (with x/y), or drop chronograph exports into the Chrono uploader.");
      return;
    }
    for (const f of csvFiles){
      try{
        const text = await f.text();
        // Heuristic: Garmin "Rifle_Bullet_*.csv" (chrono export) has no x/y columns.
        // If we see chrono-specific headers, route to Chrono instead of throwing ShotMarker x/y errors.
        if (/Speed\s*\(FPS\)/i.test(text) && (/KE\s*\(FT-?LBS\)/i.test(text) || /Power\s*Factor/i.test(text) || /Clean\s*Bore/i.test(text) || /Cold\s*Bore/i.test(text))){
          await handleChronoFiles([f], imp);
          imp.notes.push(`Auto-detected chronograph export "${f.name}" dropped in ShotMarker; imported under Chrono.`);
          continue;
        }
        // Distance: prefer ShotMarker-provided metadata when available
        const dFound = extractDistanceYdFromShotMarker(text);
        if (dFound != null){
          imp.distanceYd = dFound;
          imp.distanceSource = "shotmarker";
        } else if (imp.distanceYd == null){
          // fallback inference (default 1000 yd) â€” user should verify
          imp.distanceYd = 1000;
          imp.distanceSource = "inferred";
        }

        const groups = parseShotMarkerMulti(text, f.name);
        for (let gi=0; gi<groups.length; gi++){
          const g = groups[gi];
          const parsed = { headers: g.headers || [], rows: g.rows || [] };
          const headers = parsed.headers || [];
          // try to find horizontal/vertical columns (ShotMarker uses x mm / y mm)
          const xCol = findCol(headers, ["x", "x mm", "xmm", "horiz", "horizontal", "dx", "x(in)", "x_in", "xinch", "x_inches"]);
          const yCol = findCol(headers, ["y", "y mm", "ymm", "vert", "vertical", "dy", "y(in)", "y_in", "yinch", "y_inches"]);
          if (!imp.diagnostics) imp.diagnostics = [];
          const hdrSample = (headers || []).slice(0, 10);
          // We'll record what we detected even if we fail later.
          if (!xCol || !yCol){
            imp.diagnostics.push({
              file: f.name,
              block: gi+1,
              kind: "ShotMarker",
              map: "missing x/y columns",
              warnings: ["Couldn't detect x/y columns"],
              sample: hdrSample
            });
            // If this "ShotMarker" file is actually a chrono export, route it.
            if ((/Speed\s*\(FPS\)/i.test(hdrSample) || /KE\s*\(FT-?LBS\)/i.test(hdrSample) || /Power\s*Factor/i.test(hdrSample) || /Clean\s*Bore/i.test(hdrSample) || /Cold\s*Bore/i.test(hdrSample)) && !(/x\s*mm/i.test(hdrSample) || /y\s*mm/i.test(hdrSample))){
              await handleChronoFiles([f], imp);
              imp.notes.push(`Auto-detected chronograph export "${f.name}" (missing x/y); imported under Chrono.`);
              continue;
            }
            imp.errors.push(`ShotMarker "${f.name}": couldn't find x/y columns in block ${gi+1}. (Expected headers like x mm / y mm.)`);
            continue;
          }

          // unit detection (very light): if header contains mm, assume mm
          const hdrJoined = headers.join(" ").toLowerCase();
          const assumeMM = hdrJoined.includes("mm");
          const shots = [];
          for (const row of parsed.rows){
            const x = toNum(row[xCol]);
            const y = toNum(row[yCol]);
            if (x == null || y == null) continue;
            shots.push({ x, y });
          }
          if (shots.length < 3){
            const sampleRow = sampleRowPreview(parsed, headers, 8);
            imp.diagnostics.push({
              file: f.name,
              block: gi+1,
              kind: "ShotMarker",
              map: `x="${xCol}" y="${yCol}"`,
              unit: assumeMM ? "mm" : "unknown",
              shotsParsed: shots.length,
              warnings: ["Too few parsed shots"],
              sample: sampleRow
            });
            imp.errors.push(`ShotMarker "${f.name}": block ${gi+1} had too few shots after parsing.`);
            continue;
          }

          // Record detection summary
          const sampleRow = sampleRowPreview(parsed, headers, 8);
          imp.diagnostics.push({
            file: f.name,
            block: gi+1,
            kind: "ShotMarker",
            map: `x="${xCol}" y="${yCol}"`,
            unit: assumeMM ? "mm" : "unknown",
            shotsParsed: shots.length,
            sample: sampleRow
          });

          // Compute metrics in MOA (Vert = vertical extreme spread, MR = mean radius)
          // We treat X/Y as mm unless we think they're inches; convert mm->in.
          const toIn = (v) => assumeMM ? (v / 25.4) : v;
          const xs = shots.map(s => toIn(s.x));
          const ys = shots.map(s => toIn(s.y));

          // center
          const mx = xs.reduce((a,b)=>a+b,0)/xs.length;
          const my = ys.reduce((a,b)=>a+b,0)/ys.length;

          const radiiIn = xs.map((x,i)=> Math.hypot(x-mx, ys[i]-my));
          const mrIn = radiiIn.reduce((a,b)=>a+b,0)/radiiIn.length;

          const yMin = Math.min(...ys);
          const yMax = Math.max(...ys);
          const vertIn = (yMax - yMin);

          // Need distance to convert inches->MOA. In spec build we assume 1000y unless user provides later.
          const distYd = imp.distanceYd || 1000;
          const moaPerIn = 100 / (1.047 * distYd); // inches at distance to MOA
          const vertMOA = vertIn * moaPerIn;
          const mrMOA = mrIn * moaPerIn;


          const isSighters = detectSightersFromShotMarkerBlock({ label: g.label || f.name, fileName: f.name, headers, rows: parsed.rows });
const t = {
            id: `SM_${slugify(f.name)}_${gi+1}`,
            fileName: (groups.length>1 ? `${f.name} (${(g.targetLabel || ("T"+(gi+1)))})` : f.name),
            sourceFile: f.name,
            label: g.label || f.name,
            timeMs: g.timeMs || null,
            shotsTotal: shots.length,
            shotsUsed: shots.length,
            vert: vertMOA,
            mr: mrMOA,
            confidence: suggestConfidence(vertMOA, mrMOA, null, shots.length),
            isSighters: isSighters
          };

          if (t.isSighters) sighterTargets++;

          // Try date extraction from label (first token like "Sep 25 2025")
          const mDate = String(g.label||"").match(/([A-Z][a-z]{2})\s+(\d{1,2})\s+(\d{4})/);
          if (mDate){
            const mon = mDate[1], day = String(mDate[2]).padStart(2,"0"), yr = mDate[3];
            const months = {Jan:"01",Feb:"02",Mar:"03",Apr:"04",May:"05",Jun:"06",Jul:"07",Aug:"08",Sep:"09",Oct:"10",Nov:"11",Dec:"12"};
            const mm = months[mon] || "01";
            t.date = `${yr}-${mm}-${day}`;
          }

          if (!t.timeMs && t.date) t.timeMs = new Date(t.date + "T00:00:00").getTime();

          // nicer label fallback
          if (!t.label){
            const nice = f.name.replace(/\.[^.]+$/,"");
            t.label = nice + (groups.length>1 ? ` â€” Target ${gi+1}` : "");
          }
          imp.smTargets.push(t);
          if ((gi % 2) === 1) await tick();
        }
      }catch(err){
        imp.errors.push(`ShotMarker "${f.name}": parse failed (${String(err?.message || err)}).`);
      }
    }

    if (sighterTargets){ imp.notes.push(`Detected ${sighterTargets} sighter-only target${sighterTargets===1?"":"s"}.`); }

    // auto-pair by order if counts match (or if pairings empty)
    autoPair(imp);
    imp.status = imp.smTargets.length ? "ShotMarker targets parsed." : imp.status;
  }


async function handleChronoFiles(files, imp){
    imp.errors = imp.errors || [];
    imp.notes = Array.isArray(imp.notes) ? imp.notes : [];

    imp.status = "";
    imp.chronoSets = Array.isArray(imp.chronoSets) ? imp.chronoSets : [];

    const beforeCount = imp.chronoSets.length;

    const allFiles = Array.from(files || []);
    let sighterTargets = 0;
    const csvFiles = allFiles.filter(f => /\.csv$/i.test(f.name));
    const xlsFiles = allFiles.filter(f => /\.(xls|xlsx)$/i.test(f.name)); // supports .xls and .xlsx (offline)

    if (!csvFiles.length && !xlsFiles.length){
      imp.errors.push("Chrono: please choose Garmin chronograph exports (.csv or .xls).");
      return;
    }

    // Helper: parse a chrono file into {headers, rows}
    async function parseChronoFile(f){
      if (/\.csv$/i.test(f.name)){
        const text = await f.text();
        return parseCSV(text);
      }
      if (/\.xls$/i.test(f.name)){
        const ab = await f.arrayBuffer();
        return parseXLS(ab);
      }
      if (/\.xlsx$/i.test(f.name)){
        const ab = await f.arrayBuffer();
        return await parseXLSX(ab);
      }
      throw new Error("Unsupported chrono type: " + f.name);
    }

    const chronoFiles = csvFiles.concat(xlsFiles);

    // Dedupe key: filename + shots + rounded stats
    const existingKeys = new Set(imp.chronoSets.map(c => {
      const a = Math.round((c.avg||0)*10)/10;
      const s = Math.round((c.sd||0)*10)/10;
      return `${String(c.fileName||"").toLowerCase()}|${c.shotsTotal||0}|${a}|${s}`;
    }));

    for (const f of chronoFiles){
      try{
        const parsed = await parseChronoFile(f);
        const headers = parsed.headers || [];

        // attempt to find velocity column (robust):
        // 1) prefer known header names
        // 2) otherwise score numeric columns by "fps plausibility"
        const cand = ["v fps","vfps","vel","velocity","fps","muzzlevelocity","muzzle velocity","speed"];
        let vals = [];
        let usedCol = null;

        const scoreVals = (arr, headerName) => {
          const a = arr.filter(x => x != null && isFinite(x));
          if (a.length < 8) return -1;

          // Velocity should look like fps: mostly 1200â€“4200
          const inRange = a.filter(x => x > 1200 && x < 4200);
          if (inRange.length < Math.max(8, a.length*0.6)) return -1;

          const m = inRange.reduce((p,c)=>p+c,0)/inRange.length;
          const sd = sampleSD(inRange);
          const minV = Math.min.apply(null, inRange);
          const maxV = Math.max.apply(null, inRange);
          const es = maxV - minV;

          const hn = normKey(headerName || "");
          let s = 0;

          // Header hints (strongly prefer real velocity columns)
          if (/(vel|velocity|fps|speed)/.test(hn)) s += 3;
          if (/(time|ms|msec|sec|seconds)/.test(hn) && !/(vel|velocity|fps|speed)/.test(hn)) return -1;
          if (/(shot|index|count|no)/.test(hn)) s -= 2;

          // Mean plausibility
          if (m >= 2200 && m <= 3300) s += 2;
          else if (m >= 1500 && m <= 3800) s += 1;
          else return -1;

          // Spread plausibility
          if (sd >= 2 && sd <= 45) s += 2;
          else if (sd < 80) s += 1;
          else return -1;

          if (es >= 15 && es <= 250) s += 1;

          // More shots is better
          s += Math.min(2, inRange.length/20);

          return s;
        };

        // pass 1: explicit header candidates
        for (const c of cand){
          const h = findCol(headers, [c]);
          if (!h) continue;
          const tmp = parsed.rows.map(r => toNum(r[h])).filter(x => x != null);
          const sc = scoreVals(tmp, h);
          if (sc >= 0){
            vals = tmp.filter(x => x > 1200 && x < 4200);
            usedCol = h;
            break;
          }
        }

        // pass 2: search all headers for best plausible fps column
        if (!vals.length){
          let bestSc = -1;
          let best = null;
          for (const h of headers){
            const tmp = parsed.rows.map(r => toNum(r[h])).filter(x => x != null);
            const sc = scoreVals(tmp, h);
            if (sc > bestSc){
              bestSc = sc;
              best = { h, tmp };
            }
          }
          if (best && bestSc >= 0){
            vals = best.tmp.filter(x => x > 1200 && x < 4200);
            usedCol = best.h;
          }
        }

        if (vals.length < 6){
          imp.errors.push(`Chrono "${f.name}": couldn't find a velocity column with enough values.`);
          continue;
        }

        const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
        const sd = Math.sqrt(vals.reduce((a,b)=>a+Math.pow(b-avg,2),0)/vals.length);
        const minV = Math.min.apply(null, vals);
        const maxV = Math.max.apply(null, vals);
        const es = maxV - minV;

        const k = `${String(f.name||"").toLowerCase()}|${vals.length}|${Math.round(avg*10)/10}|${Math.round(sd*10)/10}`;
        if (existingKeys.has(k)) continue;
        existingKeys.add(k);

        const dt = parseDateTimeFromFilename(f.name);
        if (!imp.diagnostics) imp.diagnostics = [];
        imp.diagnostics.push({
          file: f.name,
          kind: "Chrono",
          map: usedCol ? `vel="${usedCol}"` : "missing velocity column",
          unit: "fps",
          shotsParsed: vals.length,
          warnings: (!usedCol ? ["Couldn't detect velocity column"] : (vals.length < 5 ? ["Few shots detected"] : [])),
          sample: (headers || []).slice(0, 10)
        });

        imp.chronoSets.push({
          id: "CH_" + Math.random().toString(16).slice(2),
          fileName: f.name,
          shotsTotal: vals.length,
          avg,
          sd,
          minV,
          maxV,
          es,
          vels: vals,
          date: dt.date || null,
          timeMs: dt.timeMs || null,
          velCol: usedCol || null
        });
        await tick();

      }catch(e){
        imp.errors.push(`Chrono "${f.name}": ${e.message || e}`);
      }
    }

    // if new chronos came in, try timestamp pairing (then fallback pairing)
    autoPair(imp);
  }



  function autoPair(imp){
    let pairedTime = 0;
    let pairedIndex = 0;
    if (!imp || !imp.smTargets) return;
    imp.pairings = imp.pairings || {};
    if (!imp.smTargets.length || !imp.chronoSets?.length) return;

    const chronos = imp.chronoSets.slice();
    const targets = imp.smTargets.slice();

    const alreadyUsed = new Set(Object.values(imp.pairings || {}).filter(Boolean));

    const hasTimes = (arr) => arr.some(x => x && typeof x.timeMs === "number" && isFinite(x.timeMs));
    const tHas = hasTimes(targets);
    const cHas = hasTimes(chronos);

    // 1) Timestamp pairing (closest chrono within 6 hours), prefer unused chrono files.
    if (tHas && cHas){
      const MAX_DIFF = 6 * 60 * 60 * 1000;
      for (const t of targets){
        if (imp.pairings[t.id]) continue;
        if (t.timeMs == null) continue;

        let best = null;
        let bestDiff = Infinity;

        for (const c of chronos){
          if (alreadyUsed.has(c.id)) continue;
          if (c.timeMs == null) continue;
          const d = Math.abs(c.timeMs - t.timeMs);
          if (d < bestDiff){
            bestDiff = d;
            best = c;
          }
        }

        if (best && bestDiff <= MAX_DIFF){
          imp.pairings[t.id] = best.id;
          alreadyUsed.add(best.id);
        }
          pairedTime++;
      }
    }

    // 2) Fallback: if equal counts (or partial), pair by index for remaining unpaired.
    const remaining = targets.filter(t => !imp.pairings[t.id]);
    if (remaining.length){
      const avail = chronos.filter(c => !alreadyUsed.has(c.id));
      const min = Math.min(remaining.length, avail.length);
      for (let i=0;i<min;i++){
        imp.pairings[remaining[i].id] = avail[i].id;
        alreadyUsed.add(avail[i].id);
      }
        pairedIndex += min;
    }
  }

  function chronoPreview(c){
    if (!c) return "";
    const v = Array.isArray(c.vels) ? c.vels : [];
    if (!v.length) return "";
    const take = v.slice(0, 8).map(x => String(Math.round(x))).join(", ");
    return take + (v.length > 8 ? " â€¦" : "");
  }

  function chronoSummaryLine(c){
    if (!c) return "";
    const avg = (c.avg||0).toFixed(0);
    const sd = (c.sd||0).toFixed(1);
    const es = (c.es||0).toFixed(0);
    return `${c.shotsTotal||0} vels Â· Avg ${avg} Â· SD ${sd} Â· ES ${es}`;


    imp.notes = Array.isArray(imp.notes) ? imp.notes : [];
    if (pairedTime) imp.notes.push(`Auto-paired ${pairedTime} target${pairedTime===1?"":"s"} by timestamp.`);
    if (pairedIndex) imp.notes.push(`Auto-paired ${pairedIndex} target${pairedIndex===1?"":"s"} by order.`);
}

  function renderImportListsAndPairings(imp){
    // lists
    const smList = $("smList");
    const chList = $("chList");
    if (smList){
      smList.innerHTML = imp.smTargets.length ? imp.smTargets.map(t => `
        <div class="fileItem">
          <div class="nm">${escapeHTML(t.fileName)}</div>
          <div class="sm">${t.shotsTotal} shots Â· Vert <b>${(t.vert||0).toFixed(2)}</b> MOA Â· MR <b>${(t.mr||0).toFixed(2)}</b> MOA</div>
        </div>
      `).join("") : `<div class="mini" style="color:var(--muted);">No targets loaded yet.</div>`;
    }
    if (chList){
      chList.innerHTML = imp.chronoSets.length ? imp.chronoSets.map(c => `
        <div class="fileItem">
          <div class="nm">${escapeHTML(c.fileName)}</div>
          <div class="sm">${chronoSummaryLine(c)} fps</div>
          <div class="mini" style="color:var(--muted);margin-top:4px;">Preview: ${escapeHTML(chronoPreview(c))}</div>
        </div>
      `).join("") : `<div class="mini" style="color:var(--muted);">No chrono files loaded yet.</div>`;
    }

    // pairings UI
    const wrap = $("pairWrap");
    if (!wrap) return;

    if (!imp.smTargets.length){
      wrap.innerHTML = `<div class="mini" style="margin-top:10px;color:var(--muted);">Load ShotMarker targets to begin pairing.</div>`;
      return;
    }

    const chronoOpts = imp.chronoSets.map(c => `<option value="${c.id}">${escapeHTML(c.fileName)} (${c.shotsTotal} vels, SD ${(c.sd||0).toFixed(1)})</option>`).join("");

    wrap.innerHTML = imp.smTargets.map((t, idx) => {
      const sel = imp.pairings[t.id] || "";
      const paired = imp.chronoSets.find(c => c.id === sel);
      const hasChrono = !!paired;
      const conf = suggestConfidence(t.shotsTotal, hasChrono, paired ? paired.shotsTotal : 0);
      const capped = (hasChrono && paired && paired.shotsTotal && paired.shotsTotal < 15) || (!hasChrono);
      return `
        <div class="pairRow" data-tid="${t.id}">
          <div class="pairCard">
            <div class="top">
              <div>
                <div class="nm">Target ${idx+1}</div>
                <div class="meta">${escapeHTML(t.fileName)}<br/>${t.shotsTotal} shots Â· Dist ${(t.distanceYd||imp.distanceYd||"â€”")} yd Â· Vert ${(t.vert||0).toFixed(2)} Â· MR ${(t.mr||0).toFixed(2)}</div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;">
                <div class="chip conf ${conf}">${CONF_LABEL[conf]}</div>
                ${capped ? `<div class="chip impact bad" title="Confidence capped due to data quality.">${!hasChrono?"âš ï¸ No chrono":"âš ï¸ Short chrono"}</div>` : ``}
              </div>
            </div>
          </div>
          <div class="pairCard">
            <div class="nm">Chrono</div>
            <div class="meta">${paired ? `${escapeHTML(paired.fileName)}<br/>${paired.shotsTotal} vels Â· SD ${(paired.sd||0).toFixed(1)}` : `No chrono paired (allowed, but lowers confidence)`}</div>
            <select class="select impPairSel" data-tid="${t.id}">
              <option value="">â€” None â€”</option>
              ${chronoOpts}
            </select>
          </div>
        </div>
      `;
    }).join("");

    [...wrap.querySelectorAll(".impPairSel")].forEach(sel => {
      const tid = sel.getAttribute("data-tid");
      sel.value = imp.pairings[tid] || "";
      sel.addEventListener("change", () => {
        imp.pairings[tid] = sel.value || "";
        render();
      });
    });
  }

  function generateSessionsFromImport(imp){
    const barrelId = imp.barrelId || state.selectedBarrelId || "B1";
    imp.barrelId = barrelId;

    let barrel = state.barrels.find(b => b.id === barrelId);
    if (!barrel){
      barrel = { id: barrelId, display: barrelId, startRounds: 0 };
      state.barrels.push(barrel);
      state.selectedBarrelId = barrelId;
    }

    const created = [];
    for (let i=0;i<imp.smTargets.length;i++){
      const t = imp.smTargets[i];
      const chronoId = imp.pairings[t.id] || "";
      const chrono = chronoId ? imp.chronoSets.find(c => c.id === chronoId) : null;

      const conf = suggestConfidence(t.shotsTotal, !!chrono, chrono ? chrono.shotsTotal : 0);
      if (chrono && chrono.shotsTotal && chrono.shotsTotal < 15){
        imp.errors = Array.isArray(imp.errors) ? imp.errors : [];
        const msg = `Chrono warning: "${chrono.fileName}" has only ${chrono.shotsTotal} shots (confidence capped).`;
        if (!imp.errors.includes(msg)) imp.errors.push(msg);
      }
      if (!chrono){
        imp.errors = Array.isArray(imp.errors) ? imp.errors : [];
        const msg2 = `Pairing note: target "${(t.name||t.label||t.id)}" has no chrono paired (confidence capped).`;
        if (!imp.errors.includes(msg2)) imp.errors.push(msg2);
      }
      const date = t.date || chrono?.date || new Date().toISOString().slice(0,10);
      const label = `${new Date(date+"T00:00:00").toLocaleDateString(undefined,{month:"short",day:"2-digit",year:"numeric"})} â€” ${(t.fileName || t.sourceFile || "ShotMarker").replace(/\.[^.]+$/,"")}`;

      created.push({
        id: `S_${Date.now()}_${Math.random().toString(16).slice(2)}`,
        barrelId,
        date,
        label,
        isSighters: !!t.isSighters,
        shotsUsed: Math.min(20, t.shotsTotal || 0) || (t.shotsTotal || 0),
        shotsTotal: t.shotsTotal || 0,
        mr: t.mr || 0,
        vert: t.vert || 0,
        sd: chrono ? (chrono.sd || 0) : 0,
        confidence: conf,
        sourceFile: `${t.fileName}${chrono ? " + " + chrono.fileName : ""}`,
        sourceType: "shotmarker",
        notes: ""
      });
    }

    // push and re-render
    state.sessions.push(...created);
    imp.generatedCount = created.length;
    imp.generatedAtISO = new Date().toISOString();
}

  function clearAll(){
    state.barrels = [{ id:"B1", display:"B1" }];
    state.sessions = [];
    state.selectedBarrelId = "B1";
    state.detailMode = "timeline";
    state.draft = null;
    state.importer = null;
    bumpRev();
  }


function defaultDraft(barrelId){
  const today = new Date();
  const iso = today.toISOString().slice(0,10);
  return {
    barrelId: barrelId || state.selectedBarrelId || (state.barrels[0]?.id || ""),
    date: iso,
    label: "",
    isSighters: false,
    shotsUsed: 20,
    shotsTotal: 22,
    vert: 0.00,
    mr: 0.00,
    sd: 0.0,
    confidence: "mod",
    sourceFile: "",
    notes: ""
  };
}

function openAddSession(barrelId){
  state.detailMode = "manual";
  state.draft = defaultDraft(barrelId);
  render();
}

function openImport(barrelId){
  state.detailMode = "import";
  state.draft = null;
  render();
}

function closeAddSession(){
  state.detailMode = "timeline";
  state.draft = null;
  renderDetail();
}

function ensureBarrel(id){
  const bid = String(id || "").trim();
  if (!bid) return null;
  const existing = state.barrels.find(b => b.id === bid);
  if (existing){
    if (existing.startRounds == null || !Number.isFinite(Number(existing.startRounds))) existing.startRounds = 0;
    return existing;
  }
  const b = { id: bid, display: bid, startRounds: 0 };
  state.barrels.push(b);
  return b;
}

async function deleteBarrelById(bid){
  const id = String(bid || "").trim();
  if (!id) return;
  const barrel = state.barrels.find(b => b.id === id);
  if (!barrel) return;

  const sess = state.sessions.filter(s => s.barrelId === id);
  const sessCount = sess.length;

  const msg = sessCount
    ? `Delete barrel "${id}"?\n\nThis will also delete ${sessCount} session${sessCount===1?"":"s"} attached to it.\n\nTip: You'll get a one-click Undo right after delete.`
    : `Delete barrel "${id}"?\n\nTip: You'll get a one-click Undo right after delete.`;

  const ok = await confirmDialog(msg, { title:"Delete barrel", okText:"Delete", cancelText:"Cancel" });
  if (!ok) return;

  const barrelIdx = state.barrels.findIndex(b => b.id === id);
  const removedBarrel = deepClone(barrel);
  const removedSessions = sess.map(deepClone);

  state.barrels = state.barrels.filter(b => b.id !== id);
  state.sessions = state.sessions.filter(s => s.barrelId !== id);

  if (!state.barrels.length){
    state.barrels = [{ id:"B1", display:"B1", startRounds:0 }];
  }

  if (state.selectedBarrelId === id){
    state.selectedBarrelId = state.barrels[0]?.id || "B1";
  }

  state.detailMode = "timeline";
  state.draft = null;
  bumpRev();
  render();

  toast(`Barrel ${id} deleted.`, "success", "Deleted", 6500, {
    actionLabel: "Undo",
    onAction: () => {
      if (!state.barrels.some(b => b.id === removedBarrel.id)){
        const ins = Math.max(0, Math.min(barrelIdx, state.barrels.length));
        state.barrels.splice(ins, 0, removedBarrel);
      }
      const existing = new Set(state.sessions.map(s => s.id));
      removedSessions.forEach(s => { if (!existing.has(s.id)) state.sessions.push(s); });

      state.selectedBarrelId = removedBarrel.id;
      state.detailMode = "timeline";
      state.draft = null;
      bumpRev();
      render();
    }
  });
}


  function sessionsForBarrel(barrelId){
    return state.sessions
      .filter(s => s.barrelId === barrelId)
      .filter(s => state.showSighters ? true : !s.isSighters)
      .sort((a,b) => (a.date < b.date ? 1 : -1));
  }

  function allSessionsForBarrel(barrelId){
    return state.sessions
      .filter(s => s.barrelId === barrelId)
      .sort((a,b) => (a.date < b.date ? 1 : -1));
  }

  function getBarrelStartRounds(barrelId){
    const b = state.barrels.find(b => b.id === barrelId);
    const n = Number(b && b.startRounds);
    return (Number.isFinite(n) && n > 0) ? Math.floor(n) : 0;
  }

  function lifeRounds(barrelId){
    const base = getBarrelStartRounds(barrelId);
    const fired = allSessionsForBarrel(barrelId).reduce((acc,s)=>acc + (s.shotsTotal || 0), 0);
    return base + fired;
  }

  function formWindowSessions(barrelId){
    const list = sessionsForBarrel(barrelId).slice();
    let rounds = 0;
    const picked = [];
    for (const s of list){
      if (!s.shotsTotal) continue;
      if (rounds >= state.windowRounds) break;
      picked.push(s);
      rounds += s.shotsTotal;
    }
    return picked;
  }

  function aggregate(barrelId){
    const win = formWindowSessions(barrelId);
    if (!win.length) return null;

    const avg = (k) => win.reduce((a,s)=>a + (s[k] ?? 0), 0) / win.length;
    const vert = avg("vert");
    const mr = avg("mr");
    const sd = avg("sd");

    const confScore = Math.max(...win.map(s => CONF_ORDER[s.confidence] || 1));
    const conf = Object.keys(CONF_ORDER).find(k => CONF_ORDER[k] === confScore) || "low";

    let score = 100 - (vert * RANK_W.vert) - (mr * RANK_W.mr) - (sd * RANK_W.sd);
    const w = CONF_MULT[conf] ?? 0.78;
    score *= w;
    score = Math.max(0, Math.min(100, score));

    const trend = (() => {
      const t = win.slice(0,3).reverse();
      if (t.length < 2) return "flat";
      const delta = (t[t.length-1].vert ?? 0) - (t[0].vert ?? 0);
      if (delta <= -0.03) return "up";
      if (delta >=  0.03) return "down";
      return "flat";
    })();

    const last = win[0]?.date || null;
    const lastLabel = (win[0]?.label || win[0]?.sourceFile || "").replace(/\.[^.]+$/,"") || "";
    return { vert, mr, sd, conf, score, trend, last, lastLabel };
  }

  function getAggCached(barrelId){
    const key = `${state.windowRounds}|${state.showSighters}|${state.rev}`;
    if (!state._cache) state._cache = { agg: new Map(), aggKey: key };
    if (state._cache.aggKey !== key){
      state._cache.aggKey = key;
      state._cache.agg = new Map();
    }
    if (state._cache.agg.has(barrelId)) return state._cache.agg.get(barrelId);
    const v = aggregate(barrelId);
    state._cache.agg.set(barrelId, v);
    return v;
  }

  function cmp(a,b){
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  }


  function passesMinConf(conf){
    return (CONF_ORDER[conf] || 1) >= (CONF_ORDER[state.minConf] || 2);
  }


  // Phase 1: explainable scoring (no logic changes)
  function scoreBreakdown(barrelId){
    const win = formWindowSessions(barrelId);
    if (!win.length) return null;

    const avg = (k) => win.reduce((a,s)=>a + (s[k] ?? 0), 0) / win.length;
    const vert = avg("vert");
    const mr = avg("mr");
    const sd = avg("sd");

    const confScore = Math.max(...win.map(s => CONF_ORDER[s.confidence] || 1));
    const conf = Object.keys(CONF_ORDER).find(k => CONF_ORDER[k] === confScore) || "low";

    const vertPenalty = vert * RANK_W.vert;
    const mrPenalty   = mr   * RANK_W.mr;
    const sdPenalty   = sd   * RANK_W.sd;
    const baseScore   = 100 - vertPenalty - mrPenalty - sdPenalty;

    const mult = CONF_MULT[conf] ?? 0.78;
    const finalScore = Math.max(0, Math.min(100, baseScore * mult));

    // â€œSharesâ€ are explanatory only (weights, not perfect attribution)
    const totalPenalty = Math.max(0.0001, vertPenalty + mrPenalty + sdPenalty);
    const pVert = (vertPenalty / totalPenalty) * 100;
    const pMr   = (mrPenalty   / totalPenalty) * 100;
    const pSd   = (sdPenalty   / totalPenalty) * 100;

    const confLabel = CONF_LABEL[conf] || conf;

    const html = `
      <div class="popRow">
        <div class="popLbl">Final</div>
        <div style="font-weight:900;font-size:16px;">${finalScore.toFixed(1)} <span style="color:var(--muted);font-weight:700;font-size:12px;">(window avg)</span></div>
      </div>
      <div style="margin:8px 0 10px; height:1px; background: rgba(255,255,255,.08);"></div>

      <div class="popRow">
        <div class="popLbl">Vertical</div>
        <div><b>${vert.toFixed(2)}</b> MOA Â· penalty <b>${vertPenalty.toFixed(1)}</b> Â· ~${pVert.toFixed(0)}%</div>
      </div>
      <div class="popRow">
        <div class="popLbl">MR</div>
        <div><b>${mr.toFixed(2)}</b> Â· penalty <b>${mrPenalty.toFixed(1)}</b> Â· ~${pMr.toFixed(0)}%</div>
      </div>
      <div class="popRow">
        <div class="popLbl">SD</div>
        <div><b>${sd.toFixed(1)}</b> fps Â· penalty <b>${sdPenalty.toFixed(1)}</b> Â· ~${pSd.toFixed(0)}%</div>
      </div>

      <div style="margin:10px 0; padding:10px 10px; border-radius:14px; border:1px solid rgba(255,255,255,.10); background: rgba(2,6,23,.35);">
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <div style="font-weight:900;">Confidence</div>
          <div class="conf ${conf}" style="font-weight:900;">${confLabel}</div>
        </div>
        <div class="mini" style="margin-top:6px;">
          Base score <b>${baseScore.toFixed(1)}</b> Ã— multiplier <b>${mult.toFixed(2)}</b> = <b>${finalScore.toFixed(1)}</b>
        </div>
      </div>

      <div class="mini">Deterministic: 100 âˆ’ (VertÂ·${RANK_W.vert} + MRÂ·${RANK_W.mr} + SDÂ·${RANK_W.sd}) then Ã— confidence multiplier.</div>
    `;
    return { vert, mr, sd, conf, baseScore, finalScore, html };
  }

  function trendSparkSVG(dir){
    if (dir === "up"){
      return `<svg class="spark" viewBox="0 0 80 18" aria-hidden="true">
                <path d="M2 14 L16 13 L30 11 L44 9 L58 6 L72 4"></path>
                <circle class="dot" cx="72" cy="4" r="2.5"></circle>
              </svg>`;
    }
    if (dir === "down"){
      return `<svg class="spark" viewBox="0 0 80 18" aria-hidden="true">
                <path d="M2 4 L16 6 L30 8 L44 10 L58 12 L72 14"></path>
                <circle class="dot" cx="72" cy="14" r="2.5"></circle>
              </svg>`;
    }
    return `<svg class="spark" viewBox="0 0 80 18" aria-hidden="true">
              <path d="M2 10 L16 10 L30 10 L44 10 L58 10 L72 10"></path>
              <circle class="dot" cx="72" cy="10" r="2.5"></circle>
            </svg>`;
  }

  function rowGlowClass(conf){
    if (conf === "high") return "glow-high";
    if (conf === "mod") return "glow-mod";
    if (conf === "low") return "glow-low";
    return "";
  }


  // Phase 3: confidence decay cue (visual only)
  function glowBoxShadow(conf, lastISO){
    if (!conf) return "";
    const base = {
      high: { r:34, g:197, b:94,  a:0.28, glow:0.08 },
      mod:  { r:245,g:158, b:11,  a:0.26, glow:0.08 },
      low:  { r:100,g:116, b:139, a:0.22, glow:0.06 },
    }[conf] || { r:100,g:116,b:139,a:0.18,glow:0.05 };

    // decay from 1.0 (fresh) to 0.35 (stale) over ~45 days
    let decay = 1.0;
    if (lastISO){
      const days = (Date.now() - new Date(lastISO + "T00:00:00").getTime()) / (1000*60*60*24);
      decay = Math.max(0.35, Math.min(1.0, 1.0 - (days/45)));
    }
    const a1 = (base.a * decay).toFixed(3);
    const a2 = (0.10 * decay).toFixed(3);
    const a3 = (base.glow * decay).toFixed(3);
    return `inset 0 0 0 1px rgba(${base.r},${base.g},${base.b},${a1}), 0 0 0 1px rgba(${base.r},${base.g},${base.b},${a2}), 0 0 22px rgba(${base.r},${base.g},${base.b},${a3})`;
  }


  // Phase 1: session impact label (simple, deterministic)
  function impactLabel(session, agg){
    if (!session || !agg) return { key:"neutral", text:"Neutral" };
    const dv = session.vert - agg.vert;
    const ds = session.sd - agg.sd;

    // Small deadband to avoid noise
    const helped = (dv <= -0.05 && ds <= 0.0);
    const hurt   = (dv >=  0.05 && ds >= 0.5);

    if (helped) return { key:"good", text:"Helped barrel" };
    if (hurt)   return { key:"bad",  text:"Hurt confidence" };
    return { key:"neutral", text:"Neutral" };
  }

  // ---------- Phase 4: Columns / Layouts ----------
  const COL_META = {
    idx:   { label:"#",            hideable:false },
    barrel:{ label:"Barrel",       hideable:false },
    rank:  { label:"Rank",         hideable:true },
    conf:  { label:"Confidence",   hideable:true },
    vert:  { label:"Vert (MOA)",   hideable:true },
    mr:    { label:"MR (MOA)",     hideable:true },
    sd:    { label:"SD (fps)",     hideable:true },
    life:  { label:"Life",         hideable:true },
    trend: { label:"Trend",        hideable:true },
    last:  { label:"Last session", hideable:true }
  };

  const LAYOUT_PRESETS = {
    Default: { rank:true, conf:true, vert:true, mr:true, sd:true, life:true, trend:true, last:true },
    Compact: { rank:true, conf:true, vert:true, mr:true, sd:false, life:true, trend:true, last:false },
    Scoring: { rank:true, conf:true, vert:true, mr:true, sd:true, life:false, trend:true, last:false }
  };

  function defaultColVis(){ return { ...LAYOUT_PRESETS.Default }; }

  function ensureUi(){
    if (!state.ui || typeof state.ui !== "object") state.ui = {};
    if (!state.ui.layout) state.ui.layout = "Default";
    if (!state.ui.colVis || typeof state.ui.colVis !== "object") state.ui.colVis = defaultColVis();
  }

  function loadUiPrefs(){
    try{
      const raw = localStorage.getItem("BT_UI_V1");
      if (!raw) return;
      const p = JSON.parse(raw);
      if (p && typeof p === "object"){
        ensureUi();
        if (p.layout) state.ui.layout = String(p.layout);
        if (p.colVis && typeof p.colVis === "object"){
          state.ui.colVis = { ...defaultColVis(), ...p.colVis };
        }
      }
    }catch(e){}
  }
  function saveUiPrefs(){
    try{
      ensureUi();
      localStorage.setItem("BT_UI_V1", JSON.stringify({ layout: state.ui.layout, colVis: state.ui.colVis }));
    }catch(e){}
  }

  function applyLayout(name){
    ensureUi();
    const n = String(name||"Default");
    if (n === "Custom"){
      state.ui.layout = "Custom";
      saveUiPrefs();
      return;
    }
    const preset = LAYOUT_PRESETS[n];
    if (preset){
      state.ui.layout = n;
      state.ui.colVis = { ...defaultColVis(), ...preset };
      saveUiPrefs();
    }
  }

  function visibleColCount(){
    ensureUi();
    const v = state.ui.colVis || defaultColVis();
    let count = 2; // idx + barrel always visible
    for (const k of ["rank","conf","vert","mr","sd","life","trend","last"]){
      if (v[k]) count++;
    }
    return count;
  }

  function applyColumnVisibility(){
    const wrap = $("rankWrap");
    if (!wrap) return;
    ensureUi();
    const v = state.ui.colVis || defaultColVis();
    for (const k of ["rank","conf","vert","mr","sd","life","trend","last"]){
      wrap.classList.toggle(`hide-${k}`, !v[k]);
    }
  }

  function confTooltip(a){
    const c = CONF_LABEL[a.conf] || a.conf;
    const parts = [];
    if (a.nSessions != null) parts.push(`${a.nSessions} session${a.nSessions===1?"":"s"} in window`);
    if (a.shotsTotal != null) parts.push(`${a.shotsTotal} shots`);
    if (a.quality && a.quality.length) parts.push(`Notes: ${a.quality.join(" | ")}`);
    return `Confidence: ${c}${parts.length ? " â€¢ " + parts.join(" â€¢ ") : ""}`;
  }
  function trendTooltip(a){
    const t = a.trend === "up" ? "Up" : a.trend === "down" ? "Down" : "Neutral";
    const dv = (a.dVert != null) ? (a.dVert>0?"+":"") + fmt2(a.dVert) + " MOA vert" : null;
    const ds = (a.dSD != null) ? (a.dSD>0?"+":"") + fmt0(a.dSD) + " fps SD" : null;
    const bits = [dv, ds].filter(Boolean);
    return `Trend: ${t}${bits.length ? " â€¢ Î” " + bits.join(", ") : ""}`;
  }



  function renderRanking(){
    const body = $("rankBody");
    if (!body) return;
    ensureUi();
    body.innerHTML = "";

    const ui = state.ui || { search:"", filter:"all", sort:"rank" };
    const q = String(ui.search || "").trim().toLowerCase();
    const filterMode = String(ui.filter || "all");
    const sortMode = String(ui.sort || "rank");

    const rows = (state.barrels || []).map(b => {
      const agg = getAggCached(b.id);
      const life = lifeRounds(b.id);
      const hasSessions = !!agg;
      return { barrel:b, agg, life, hasSessions };
    });

    // search + filter
    let filtered = rows;

    if (q){
      filtered = filtered.filter(r => {
        const hay = `${r.barrel.id} ${r.barrel.display || ""}`.toLowerCase();
        return hay.includes(q);
      });
    }

    if (filterMode === "with"){
      filtered = filtered.filter(r => r.hasSessions);
    } else if (filterMode === "needs"){
      filtered = filtered.filter(r => !r.hasSessions);
    } else if (filterMode === "lowconf"){
      filtered = filtered.filter(r => r.agg && r.agg.conf === "low");
    }

    // min confidence threshold only applies when we have an aggregate
    filtered = filtered.filter(r => !r.agg ? true : passesMinConf(r.agg.conf));

    // sorting
    const getSortVal = (r) => {
      if (sortMode === "conf") return (r.agg ? (CONF_ORDER[r.agg.conf] || 1) : -1);
      if (sortMode === "vert") return (r.agg ? r.agg.vert : Infinity);
      if (sortMode === "mr") return (r.agg ? r.agg.mr : Infinity);
      if (sortMode === "sd") return (r.agg ? r.agg.sd : Infinity);
      if (sortMode === "life") return (r.life != null ? r.life : -1);
      if (sortMode === "last") return (r.agg && r.agg.last ? r.agg.last : "");
      // rank (default): higher score first
      return (r.agg ? r.agg.score : -Infinity);
    };

    filtered.sort((a,b) => {
      // Prefer barrels with sessions ahead of empty barrels (unless explicitly filtering "needs")
      if (filterMode !== "needs"){
        if (!a.agg && !b.agg) return a.barrel.id.localeCompare(b.barrel.id);
        if (!a.agg) return 1;
        if (!b.agg) return -1;
      }

      if (sortMode === "rank"){
        return (b.agg.score - a.agg.score) || a.barrel.id.localeCompare(b.barrel.id);
      }

      const av = getSortVal(a);
      const bv = getSortVal(b);
      // numbers
      if (typeof av === "number" && typeof bv === "number"){
        return (av - bv) || a.barrel.id.localeCompare(b.barrel.id);
      }
      // strings
      return cmp(String(av), String(bv)) || a.barrel.id.localeCompare(b.barrel.id);
    });

    // Empty state
    if (!filtered.length){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td colspan="${visibleColCount()}" class="muted" style="padding:16px 12px;">
          No barrels match your filters. Try clearing search or switching â€œShowâ€.
        </td>
      `;
      body.appendChild(tr);
      return;
    }

    // render rows
    for (let i=0;i<filtered.length;i++){
      const r = filtered[i];
      const tr = document.createElement("tr");
      tr.className = "row";
      const selected = (r.barrel.id === state.selectedBarrelId);
      if (selected){
        tr.style.outline = "2px solid rgba(99,102,241,.35)";
        tr.style.outlineOffset = "-2px";
      }

      if (!r.agg){
        tr.innerHTML = `
          <td data-col="idx">${i+1}</td>
          <td data-col="barrel" class="barrel">${escapeHTML(r.barrel.display)}</td>
          <td data-col="rank" class="muted">â€”</td>
          <td data-col="conf" class="muted">â€”</td>
          <td data-col="vert" class="muted">â€”</td>
          <td data-col="mr" class="muted">â€”</td>
          <td data-col="sd" class="muted">â€”</td>
          <td data-col="life">${escapeHTML(String(r.life ?? 0))}</td>
          <td data-col="trend" class="muted">â€”</td>
          <td data-col="last" class="muted">â€”</td>
        `;
      } else {
        const a = r.agg;

        // v4.3 table styling: confidence as plain text, trend as arrow + sparkline (click opens popover)
        const confLabel = CONF_LABEL[a.conf] || a.conf;
        const confCell = `<span class="conf ${escapeHTML(a.conf)}" data-tip="${escapeHTML(confTooltip(a))}">${escapeHTML(confLabel)}</span>`;

        const trendDir = (a.trend === "up") ? "up" : (a.trend === "down") ? "down" : "flat";
        const trendArrow = (a.trend === "up") ? "â–²" : (a.trend === "down") ? "â–¼" : "â€¢";
        const trendCell = `<button type="button" class="trendMini trend ${trendDir}" data-trend="${escapeHTML(r.barrel.id)}" data-tip="${escapeHTML(trendTooltip(a))}"><span class="trendwrap"><span class="arrow">${trendArrow}</span>${trendSparkSVG(a.trend)}</span></button>`;

tr.innerHTML = `
          <td data-col="idx">${i+1}</td>
          <td data-col="barrel" class="barrel">${escapeHTML(r.barrel.display)}</td>
          <td data-col="rank"><b>${fmt1(a.score)}</b></td>
          <td data-col="conf">${confCell}</td>
          <td data-col="vert">${fmt2(a.vert)}</td>
          <td data-col="mr">${fmt2(a.mr)}</td>
          <td data-col="sd">${fmt1(a.sd)}</td>
          <td data-col="life">${escapeHTML(String(r.life ?? 0))}</td>
          <td data-col="trend">${trendCell}</td>
          <td data-col="last" class="lastCol">${renderLastSessionCell(a)}</td>
        `;
}

      tr.addEventListener("click", () => {
        state.selectedBarrelId = r.barrel.id;
        state.detailMode = "timeline";
        state.draft = null;
        render(); // keep ranking + detail in sync
      });

      body.appendChild(tr);
    }
    applyColumnVisibility();
  }

  function renderDetail(){

    // UI mode tweaks: keep "Form window" control out of Import view
    const selWindowEl = $("selWindow");
    if (selWindowEl){
      selWindowEl.style.display = (state.detailMode === "import") ? "none" : "";
    }
  const id = state.selectedBarrelId;
  const title = $("detailTitle");
  const sub = $("detailSub");
  const meta = $("detailMeta");
  const actions = $("detailActions");
  const body = $("detailBody");

  if (!actions) return;

  // nothing selected: guide user + allow quick add barrel
  if (!id){
    title.textContent = "Select a barrel row";
    sub.textContent = "Click a row in the ranking strip to preview its timeline list â€” then import or add sessions from the drawer.";
    meta.textContent = "";
    actions.innerHTML = `<button class="btn sm primary" id="btnQuickImport" disabled title="Select a barrel first">Import</button><button class="btn sm" id="btnQuickManual" disabled title="Select a barrel first">+ Manual</button>`;
    body.innerHTML = `
      <div class="mini">
        No barrel selected yet.
        <br/><br/>
        <b>Tip:</b> Click any barrel row, then use <b>+ Add session</b> here to enter a manual session.
        <br/><br/>
        ${state.barrels.length ? "" : `<div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.08);">
            <div style="font-weight:800;margin-bottom:8px;">Quick add a barrel (spec build)</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
              <input id="quickBarrelId" class="select" style="min-width:160px;" placeholder="e.g., B1" />
              <button class="btn sm" id="btnQuickAddBarrel">Add barrel</button>
            </div>
            <div class="mini" style="margin-top:6px;">This is only for the spec build so you can test the drawer without imports.</div>
          </div>`}
      </div>
    `;

    const qb = $("btnQuickAddBarrel");
    if (qb){
      qb.addEventListener("click", () => {
        const v = ($("quickBarrelId")?.value || "").trim();
        const b = ensureBarrel(v);
        if (!b) return;
        state.selectedBarrelId = b.id;
        state.detailMode = "timeline";
        bumpRev();
        toast(replace ? "JSON imported (replaced current data)." : "JSON imported (merged with current data).", "success");
        render();
      });
    }
    return;
  }

  const b = state.barrels.find(x => x.id === id) || { id, display: id };
  const list = sessionsForBarrel(id).sort((a,b) => (a.date < b.date ? 1 : -1));
  const agg = aggregate(id);

  // actions
  if (state.detailMode === "manual"){
    actions.innerHTML = `
      <button class="btn sm" id="btnBackToTimeline">Back</button>
      <button class="btn sm primary" id="btnSaveSession">Save session</button>
      <button class="btn sm danger" id="btnDeleteBarrel" data-tip="Delete this barrel (and its sessions)">Delete barrel</button>
    `;
  } else if (state.detailMode === "import"){
    actions.innerHTML = `
      <button class="btn sm" id="btnBackToTimeline">Back</button>
      <button class="btn sm" id="btnOpenManual">+ Manual</button>
      <button class="btn sm danger" id="btnDeleteBarrel" data-tip="Delete this barrel (and its sessions)">Delete barrel</button>
    `;
  } else {
    actions.innerHTML = `
      <button class="btn sm primary" id="btnOpenImport">Import</button>
      <button class="btn sm" id="btnOpenManual">+ Manual</button>
      <button class="btn sm danger" id="btnDeleteBarrel" data-tip="Delete this barrel (and its sessions)">Delete barrel</button>
    `;
  }

  // header copy
  title.textContent = state.detailMode === "manual" ? `${b.display} â€” Manual Session` : (state.detailMode === "import" ? `${b.display} â€” Import` : `${b.display} â€” Timeline`);
  sub.textContent = agg
    ? `Current form window: last ${state.windowRounds} rounds Â· Confidence: ${CONF_LABEL[agg.conf]}`
    : `No sessions yet`;
  meta.textContent = `Life: ${lifeRounds(id)} rds`;

  if (state.detailMode === "manual"){
    if (!state.draft) state.draft = defaultDraft(id);
    state.draft.barrelId = id;

    body.innerHTML = `
      <div class="sessionRow" style="margin-bottom:14px;">
        <div class="sessionTitle">Manual session entry</div>
        <div class="mini" style="margin-top:6px;">This creates a session row that immediately feeds the ranking strip and timeline.</div>
      </div>

      <div class="sessionRow" id="previewWrap" style="margin-bottom:14px;opacity:.95;">
        <div class="sessionTitle">Preview</div>
        <div class="mini" style="margin-top:6px;color:var(--muted);">This is exactly how the session will appear in the timeline.</div>
        <div style="margin-top:10px;" id="previewRow"></div>
      </div>

      </div>

      <div class="kpis" style="grid-template-columns:repeat(2,minmax(0,1fr));">
        <div class="kpi">
          <div class="lbl">Date</div>
          <input id="fDate" type="date" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">Confidence</div>
          <select id="fConf" class="select" style="width:100%;margin-top:6px;">
            <option value="low">Low</option>
            <option value="mod">Moderate</option>
            <option value="high">High</option>
          </select>
          <div class="mini" id="confHint" style="margin-top:6px;color:var(--muted);">Suggested confidence: â€”</div>
        </div>
      </div>

      <div class="kpi" style="margin-bottom:12px;">
        <div class="lbl">Label (shows in timeline)</div>
        <input id="fLabel" class="select" style="width:100%;margin-top:6px;" placeholder="e.g., Oct 11 2025 â€” M2 R1 TT9-218 â€” #218 (T9-218)" />
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px;">
          <label class="toggle" style="padding:6px 10px;"><input id="fSighters" type="checkbox" /> Sighters session</label>
          <div class="mini">If unchecked, this counts as record shots.</div>
        </div>
      </div>

      <div class="kpis">
        <div class="kpi">
          <div class="lbl">Shots used</div>
          <input id="fUsed" type="number" min="0" step="1" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">Shots total</div>
          <input id="fTotal" type="number" min="0" step="1" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">Vert (MOA)</div>
          <input id="fVert" type="number" step="0.01" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">MR (MOA)</div>
          <input id="fMR" type="number" step="0.01" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">SD (fps)</div>
          <input id="fSD" type="number" step="0.1" class="select" style="width:100%;margin-top:6px;" />
        </div>
        <div class="kpi">
          <div class="lbl">Source file (optional)</div>
          <input id="fFile" class="select" style="width:100%;margin-top:6px;" placeholder="Rifle_Bullet_YYYY-MM-DD_..." />
        </div>
      </div>

      <details style="margin-top:10px;">
        <summary style="cursor:pointer;color:#b6c3f2;font-weight:800;">Optional notes</summary>
        <div style="margin-top:10px;">
          <textarea id="fNotes" class="select" style="width:100%;min-height:90px;resize:vertical;" placeholder="Notes (wind, mirage, call quality, equipment changes, etc.)"></textarea>
        </div>
      </details>

      <div class="mini" id="formErr" style="margin-top:10px;color:#fca5a5;display:none;"></div>
    `;

    // hydrate fields
    $("fDate").value = state.draft.date || "";
    $("fConf").value = state.draft.confidence || "mod";
    $("fLabel").value = state.draft.label || "";
    $("fSighters").checked = !!state.draft.isSighters;
    $("fUsed").value = String(state.draft.shotsUsed ?? 0);
    $("fTotal").value = String(state.draft.shotsTotal ?? 0);
    $("fVert").value = String(state.draft.vert ?? 0);
    $("fMR").value = String(state.draft.mr ?? 0);
    $("fSD").value = String(state.draft.sd ?? 0);
    $("fFile").value = state.draft.sourceFile || "";
    $("fNotes").value = state.draft.notes || "";
    function suggestConfidence(d){
      const num = (x)=> Number.isFinite(x) ? x : NaN;
      const shots = num(d.shotsTotal);
      const vert = num(d.vert);
      const sd = num(d.sd);
      const mr = num(d.mr);

      if (!Number.isFinite(shots) || !Number.isFinite(vert) || !Number.isFinite(sd) || !Number.isFinite(mr)){
        return null;
      }
      // Heuristic: reward enough rounds + strong vertical/SD; conservative by design.
      if (shots >= 20 && vert <= 0.45 && sd <= 10 && mr <= 0.85) return "high";
      if (shots >= 15 && vert <= 0.60 && sd <= 14 && mr <= 1.00) return "mod";
      return "low";
    }

    function renderPreview(){
      const d = state.draft || defaultDraft(id);
      const pr = $("previewRow");
      const hint = $("confHint");
      if (!pr) return;

      const label = (d.label || "").trim() || "(no label yet)";
      const chips = [];
      chips.push(`<span class="chip sighters">${d.isSighters ? "Sighters" : "Record"}</span>`);
      if (Number.isFinite(d.shotsUsed) && Number.isFinite(d.shotsTotal) && d.shotsTotal > 0){
        chips.push(`<span class="chip">${d.shotsUsed}/${d.shotsTotal}</span>`);
      }
      if (Number.isFinite(d.vert)) chips.push(`<span class="chip">Vert ${Number(d.vert).toFixed(2)} MOA</span>`);
      if (Number.isFinite(d.mr))   chips.push(`<span class="chip">MR ${Number(d.mr).toFixed(2)} MOA</span>`);
      if (Number.isFinite(d.sd))   chips.push(`<span class="chip">SD ${Number(d.sd).toFixed(1)} fps</span>`);
      chips.push(`<span class="chip conf ${d.confidence}">${CONF_LABEL[d.confidence] || d.confidence}</span>`);

      const sug = suggestConfidence(d);
      if (hint){
        if (!sug){
          hint.textContent = "Suggested confidence: â€”";
          hint.style.color = "var(--muted)";
        } else {
          hint.textContent = `Suggested confidence: ${CONF_LABEL[sug]}`;
          hint.style.color = sug === "high" ? "var(--hi)" : (sug === "mod" ? "var(--mod)" : "var(--low)");
        }
      }

      pr.innerHTML = `
        <div class="sessionRow" style="margin:0;background:rgba(2,6,23,.20);">
          <div class="sessionTitle">${label}</div>
          <div class="chips">${chips.join("")}</div>
          <div class="fileLine">${(d.sourceFile || "").trim()}</div>
        </div>
      `;
    }

    function syncDraftFromFields(){
      state.draft = {
        barrelId: id,
        date: ($("fDate")?.value || "").trim(),
        confidence: ($("fConf")?.value || "mod"),
        label: ($("fLabel")?.value || "").trim(),
        isSighters: !!$("fSighters")?.checked,
        shotsUsed: Number(($("fUsed")?.value || "").trim()),
        shotsTotal: Number(($("fTotal")?.value || "").trim()),
        vert: Number(($("fVert")?.value || "").trim()),
        mr: Number(($("fMR")?.value || "").trim()),
        sd: Number(($("fSD")?.value || "").trim()),
        sourceFile: ($("fFile")?.value || "").trim(),
        notes: ($("fNotes")?.value || "").trim()
      };
      // guard NaNs for preview formatting
      ["shotsUsed","shotsTotal","vert","mr","sd"].forEach(k=>{
        if (!Number.isFinite(state.draft[k])) state.draft[k] = NaN;
      });
      renderPreview();
    }

    // live preview + confidence hint
    ["fDate","fConf","fLabel","fSighters","fUsed","fTotal","fVert","fMR","fSD","fFile","fNotes"].forEach(fid=>{
      const el = $(fid);
      if (!el) return;
      el.addEventListener("input", syncDraftFromFields);
      el.addEventListener("change", syncDraftFromFields);
    });
    renderPreview();


    $("btnBackToTimeline")?.addEventListener("click", closeAddSession);
    $("btnSaveSession")?.addEventListener("click", () => {
      const err = $("formErr");
      const getNum = (id) => {
        const v = ($(id)?.value ?? "").toString().trim();
        return v === "" ? NaN : Number(v);
      };

      const draft = {
        barrelId: id,
        date: $("fDate")?.value || "",
        label: ($("fLabel")?.value || "").trim(),
        isSighters: !!$("fSighters")?.checked,
        shotsUsed: Math.round(getNum("fUsed")),
        shotsTotal: Math.round(getNum("fTotal")),
        vert: getNum("fVert"),
        mr: getNum("fMR"),
        sd: getNum("fSD"),
        confidence: $("fConf")?.value || "mod",
        sourceFile: ($("fFile")?.value || "").trim(),
        notes: ($("fNotes")?.value || "").trim()
      };

      // minimal validation
      const problems = [];
      if (!draft.date) problems.push("Date is required.");
      if (!draft.label) problems.push("Label is required.");
      if (!Number.isFinite(draft.shotsTotal) || draft.shotsTotal <= 0) problems.push("Shots total must be > 0.");
      if (!Number.isFinite(draft.vert) || draft.vert < 0) problems.push("Vert must be a valid number.");
      if (!Number.isFinite(draft.mr) || draft.mr < 0) problems.push("MR must be a valid number.");
      if (!Number.isFinite(draft.sd) || draft.sd < 0) problems.push("SD must be a valid number.");
      if (!["low","mod","high"].includes(draft.confidence)) problems.push("Confidence must be Low/Moderate/High.");

      if (draft.shotsUsed > draft.shotsTotal) problems.push("Shots used cannot exceed shots total.");
      if (draft.shotsUsed < 0) problems.push("Shots used cannot be negative.");

      if (problems.length){
        if (err){
          err.style.display = "block";
          err.textContent = problems.join(" ");
        }
        return;
      }

      const nextId = "M" + Math.random().toString(36).slice(2,9).toUpperCase();
      state.sessions.push({
        id: nextId,
        barrelId: draft.barrelId,
        date: draft.date,
        label: draft.label,
        isSighters: draft.isSighters,
        shotsUsed: draft.shotsUsed,
        shotsTotal: draft.shotsTotal,
        mr: draft.mr,
        vert: draft.vert,
        sd: draft.sd,
        confidence: draft.confidence,
        sourceFile: draft.sourceFile,
        sourceType: "manual",
        notes: draft.notes
      });
      bumpRev();
      toast("Session saved.", "success");

      state.detailMode = "timeline";
      state.draft = null;
      render();
    });

    return;
  }



if (state.detailMode === "import"){
    if (!state.importer || state.importer.barrelId !== id){
      state.importer = {
        barrelId: id,
        distanceYd: null,
        distanceSource: null,
        smTargets: [],    // parsed targets from ShotMarker files
        chronoSets: [],   // parsed velocity sets
        notes: [],       // import notes (collapsed)
        diagnostics: [], // detected fields + parsing summary
        pairings: {},     // targetId -> chronoId
        errors: [],
        status: ""
      };
    }

    const imp = state.importer;

    body.innerHTML = `
      <div class="mini" style="margin-bottom:10px;color:var(--muted);">
        Import creates <b>session rows</b> for this barrel. Everything stays local in your browser.
      </div>

      <div class="impStepper" id="impStepper"></div>

      <div class="kpis" style="margin-bottom:12px;">
        <div class="kpi">
          <div class="lbl">Distance (yd)</div>
          <div class="val" style="font-size:16px;margin-top:6px;">
            <input id="impDist" class="select" style="width:100%;max-width:160px" type="number" min="50" step="1" value="${imp.distanceYd ?? ""}" placeholder="e.g., 1000">
          </div>
          <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px;">
            <button class="btn sm" data-setdist="100">100</button>
            <button class="btn sm" data-setdist="600">600</button>
            <button class="btn sm" data-setdist="1000">1000</button>
            <button class="btn sm" data-setdist="1200">1200</button>
          </div>
          <div class="mini" style="margin-top:6px;color:var(--muted);">
            Source: <b>${imp.distanceSource || "â€”"}</b> Â· Confidence: <b>${(imp.distanceSource==="shotmarker"||imp.distanceSource==="manual")?"high":(imp.distanceSource==="inferred"?"low":"â€”")}</b>
          </div>
        </div>
        <div class="kpi">
          <div class="lbl">Parsed</div>
          <div class="val" style="font-size:16px;margin-top:6px;">${imp.smTargets.length} targets Â· ${imp.chronoSets.length} chronos</div>
          <div class="mini" id="impStatus" style="margin-top:6px;color:var(--muted);">${imp.status || ""}</div>
        </div>
      </div>

      ${(imp.errors && imp.errors.length) ? renderImportErrorBox(imp.errors) : ""}


      ${(imp.notes && imp.notes.length) ? `
        <details class="impNotes" style="margin-top:10px;">
          <summary style="cursor:pointer;font-weight:800;">Import notes (details)</summary>
          <div class="mini" style="margin-top:6px;color:var(--muted);line-height:1.5;">${renderImportNotes(imp.notes)}</div>
        </details>
      ` : ""}

      ${(imp.diagnostics && imp.diagnostics.length) ? `
        <details class="impNotes" open style="margin-top:10px;">
          <summary style="cursor:pointer;font-weight:900;">Detected fields</summary>
          <div class="mini" style="margin-top:6px;color:var(--muted);line-height:1.5;">${renderImportDiagnostics(imp.diagnostics)}</div>
        </details>
      ` : ""}

      <div class="impGrid">
        <div class="drop" id="dropSM">
          <div class="dropTop">
            <div>
              <div class="dropTitle">ShotMarker target files</div>
              <div class="dropSub">Drop <b>.csv</b> here (one or many). Weâ€™ll compute Vert & MR.</div>
            </div>
            <div>
              <input id="impSMInput" type="file" accept=".csv,text/csv" multiple style="display:none">
              <button class="btn sm" id="btnPickSM">Choose files</button>
            </div>
          </div>
          <div class="fileList" id="smList"></div>
        </div>

        <div class="drop" id="dropCH">
          <div class="dropTop">
            <div>
              <div class="dropTitle">Chrono files</div>
              <div class="dropSub">Drop velocity <b>.csv</b> here. Weâ€™ll compute SD. (XLS/XLSX later.)</div>
            </div>
            <div>
              <input id="impCHInput" type="file" accept=".csv,.xls,.xlsx,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,text/csv" multiple style="display:none">
              <button class="btn sm" id="btnPickCH">Choose files</button>
            </div>
          </div>
          <div class="fileList" id="chList"></div>
        </div>
      </div>

      <div style="margin-top:14px;">
        <div style="font-weight:800;letter-spacing:.15px;">Pair targets â†” chrono</div>
        <div class="mini" style="margin-top:6px;color:var(--muted);">Auto-pairs by order when counts match. You can change any pairing.</div>
        <div id="pairWrap"></div>

        <div class="impActions">
          <button class="btn sm" id="btnClearImport">Clear import</button>
          <button class="btn sm" id="btnClearChronos">Clear chronos only</button>
          <button class="btn sm primary" id="btnGenerateSessions" ${(imp.smTargets.length ? "" : "disabled")}>Generate sessions</button>
        </div>
      </div>
    `;

    // wire import UI
    const distEl = $("impDist");
    distEl?.addEventListener("change", () => {
      const v = parseFloat(distEl.value || "1000");
      imp.distanceYd = Math.max(1, isFinite(v) ? v : 1000);
      imp.distanceSource = "manual";
      // re-compute metrics on existing targets
      imp.smTargets = imp.smTargets.map(t => recomputeTargetMetrics(t, imp.distanceYd));
      renderDetail();
});
    // quick distance buttons (100/600/1000/1200)
    body.querySelectorAll('button[data-setdist]').forEach(btn => {
      btn.addEventListener("click", () => {
        const v = parseFloat(btn.getAttribute("data-setdist")||"");
        if (!isFinite(v)) return;
        imp.distanceYd = v;
        imp.distanceSource = "manual";
        const distEl2 = $("impDist");
        if (distEl2) distEl2.value = String(v);
        imp.smTargets = imp.smTargets.map(t => recomputeTargetMetrics(t, imp.distanceYd));
        renderDetail();
      });
    });


    $("btnBackToTimeline")?.addEventListener("click", closeAddSession);
    $("btnOpenManual")?.addEventListener("click", () => openAddSession(id));

    $("btnPickSM")?.addEventListener("click", () => $("impSMInput")?.click());
    $("btnPickCH")?.addEventListener("click", () => $("impCHInput")?.click());

    $("impSMInput")?.addEventListener("change", async (e) => {
      const files = [...(e.target.files || [])];
      await handleShotMarkerFiles(files, imp);
      renderDetail();
    });
    $("impCHInput")?.addEventListener("change", async (e) => {
      const files = [...(e.target.files || [])];
      await handleChronoFiles(files, imp);
      renderDetail();
    });

    wireDropZone($("dropSM"), async (files) => { await handleShotMarkerFiles(files, imp); renderDetail(); });
    wireDropZone($("dropCH"), async (files) => { await handleChronoFiles(files, imp); renderDetail(); });

    $("btnClearImport")?.addEventListener("click", async () => {
      const snap = deepClone(state.importer);
      const ok = await confirmDialog(
        "Clear the current import (targets, chronos, pairings, notes)?",
        { title: "Clear import", okText: "Clear", cancelText: "Cancel" }
      );
      if (!ok) return;

      state.importer = { barrelId:id, distanceYd: (imp.distanceYd || 1000), smTargets:[], chronoSets:[], pairings:{}, errors:[], notes:[], diagnostics:[], status:"" };
      renderDetail();

      toast("Import cleared.", "warn", "Cleared", 6500, {
        actionLabel: "Undo",
        onAction: () => { state.importer = snap; renderDetail(); }
      });
    });

    $("btnClearChronos")?.addEventListener("click", async () => {
      const snap = deepClone({ chronoSets: imp.chronoSets, pairings: imp.pairings, errors: imp.errors, status: imp.status });
      const ok = await confirmDialog(
        "Clear chrono files only? (ShotMarker targets will stay.)",
        { title: "Clear chronos", okText: "Clear", cancelText: "Cancel" }
      );
      if (!ok) return;

      // Keep ShotMarker targets + distance; wipe chronos + any pairings.
      imp.chronoSets = [];
      imp.pairings = {};
      imp.errors = imp.errors || [];
      imp.status = "Chronos cleared.";
      renderDetail();

      toast("Chronos cleared.", "warn", "Cleared", 6500, {
        actionLabel: "Undo",
        onAction: () => {
          imp.chronoSets = snap.chronoSets || [];
          imp.pairings = snap.pairings || {};
          imp.errors = snap.errors || [];
          imp.status = snap.status || "";
          renderDetail();
        }
      });
    });

// render lists + pairings
    renderImportListsAndPairings(imp);

    $("btnGenerateSessions")?.addEventListener("click", () => {
      generateSessionsFromImport(imp);
      bumpRev();
      state.detailMode = "timeline";
      state.importer.status = "Sessions generated.";
      toast("Sessions generated from import.", "success");
      render();
    });

    // stepper + tooltip cleanup
    updateImportStepper(imp);
    purgeNativeTooltips(body);

    return;
  }


  // timeline mode
  const sessionHtml = list.length ? list.map(s => {
    const chips = [];
    chips.push(`<span class="chip sighters">${s.isSighters ? "Sighters" : "Record"}</span>`);
    if (s.shotsUsed && s.shotsTotal) chips.push(`<span class="chip">${s.shotsUsed}/${s.shotsTotal}</span>`);
    chips.push(`<span class="chip">Vert ${s.vert.toFixed(2)} MOA</span>`);
    chips.push(`<span class="chip">MR ${s.mr.toFixed(2)} MOA</span>`);
    chips.push(`<span class="chip">SD ${s.sd.toFixed(1)} fps</span>`);
    const confTxt = (CONF_LABEL[s.confidence] || s.confidence);
    const confTip = `Confidence: ${confTxt} â€” trust in the data (sample size + consistency + data quality). It scales Rank; it doesnâ€™t â€œcreateâ€ performance.`;
    chips.push(`<span class="chip conf ${s.confidence}" data-tip="${escapeHTML(confTip)}">${escapeHTML(confTxt)}</span>`);
    const imp = impactLabel(s, agg);
    const impTip = (imp.key==="good") ? "Session impact vs rolling baseline: improved Vert by â‰¥0.05 MOA and did not increase SD." :
      (imp.key==="bad") ? "Session impact vs rolling baseline: worsened Vert by â‰¥0.05 MOA and increased SD by â‰¥0.5 fps." :
      "Session impact vs rolling baseline: within the noise band (no clear improvement/regression).";
    chips.push(`<span class="chip impact ${imp.key}" data-tip="${escapeHTML(impTip)}">${imp.key==="good"?"ðŸŸ¢":imp.key==="bad"?"ðŸ”´":"âšª"} ${escapeHTML(imp.text)}</span>`);

    return `
      <div class="sessionRow" data-sid="${s.id}">
        <div class="rowTop">
          <div class="sessionTitle">${s.label}</div>
          <button class="iconBtn" data-action="edit" data-sid="${s.id}" title="Edit session">âœŽ</button>
        </div>
        <div class="chips">${chips.join("")}</div>
        <div class="fileLine">${s.sourceFile || ""}</div>
      </div>
    `;
  }).join("") : `
    <div class="mini">
      No sessions yet for this barrel.
      <br/><br/>
      Use <b>+ Add session</b> to enter a manual session (imports get wired after).
    </div>
  `;

  body.innerHTML = sessionHtml;

  // click-to-edit on session rows
  body.querySelectorAll(".sessionRow[data-sid]").forEach(row=>{
    row.addEventListener("click", (ev) => {
      const btn = ev.target && ev.target.closest ? ev.target.closest("[data-action='edit']") : null;
      const sid = (btn && btn.getAttribute("data-sid")) || row.getAttribute("data-sid");
      if (sid) openSessionModal(sid);
    });
  });

  $("btnOpenImport")?.addEventListener("click", () => openImport(id));
  $("btnOpenManual")?.addEventListener("click", () => openAddSession(id));
  $("btnBackToTimeline")?.addEventListener("click", closeAddSession);
  $("btnDeleteBarrel")?.addEventListener("click", () => { deleteBarrelById(id); });
}

  function renderLabels(){
    $("lblWindow").textContent = String(state.windowRounds);
    $("lblMinConf").textContent = CONF_LABEL[state.minConf] || "Moderate";
    $("lblSighters").textContent = state.showSighters ? "Show sighters" : "Hide sighters";
    const sw = $("selWindow");
    if (sw) sw.style.display = (state.detailMode === "import") ? "none" : "";

    // Phase 4: scope lock UI
    const btnLock = $("btnLockScope");
    const chip = $("scopeLockChip");
    const lockedWhen = state.lockedAtISO ? new Date(state.lockedAtISO).toLocaleString() : "";
    const lockedRounds = (state.lockedWindowRounds ?? state.windowRounds);

    if (btnLock){
      btnLock.textContent = state.rankLocked ? "Unlock scope" : "Lock scope";
      const tip = state.rankLocked
        ? `Rankings frozen at ${lockedRounds} rds${lockedWhen ? " ("+lockedWhen+")" : ""}.\n\nTip: Unlock to change the Form window.`
        : "Freeze rankings to prevent accidental scope changes mid-match";
      btnLock.setAttribute("data-tip", tip);
    }

    if (chip){
      if (state.rankLocked){
        chip.style.display = "inline-flex";
        chip.innerHTML = `ðŸ”’ <b>Locked</b> @ ${lockedRounds} rds`;
        chip.setAttribute("data-tip", `Scope is locked. Rankings wonâ€™t change if you bump the window.\nLocked at: ${lockedWhen || "(time unknown)"}.`);
      }else{
        chip.style.display = "inline-flex";
        chip.innerHTML = `ðŸ”“ <b>Live</b>`;
        chip.setAttribute("data-tip", "Scope is live. Rankings update when you change the Form window.");
      }
    }

    if (sw){
      sw.disabled = !!state.rankLocked;
      if (state.rankLocked) sw.value = String(state.lockedWindowRounds ?? state.windowRounds);
    }
  }

  function render(){
    document.body.dataset.mode = state.detailMode || "ranking";
    renderLabels();
    renderRanking();
    renderDetail();

    // Hide form-window control during Import view (keep only in ranking header)
    const win = $("selWindow");
    if (win) win.style.display = (state.detailMode === "import") ? "none" : "";

    // Kill native title-tooltips (use our blue tooltips everywhere)
    purgeNativeTooltips(document);
  }


  // ---- Session Edit Modal ----
  let _editingSessionId = null;

  function sessionById(id){
    return state.sessions.find(s => s.id === id) || null;
  }

  function openSessionModal(sessionId){
    const s = sessionById(sessionId);
    if (!s) return;
    _editingSessionId = sessionId;

    const modal = $("sessModal");
    const err = $("sessModalErr");
    if (err){ err.style.display = "none"; err.textContent = ""; }

    $("sessModalTitle").textContent = "Edit session";
    $("sessModalSub").textContent = `${s.barrelId} Â· ${s.id}`;

    $("eDate").value = (s.date || "").slice(0,10);
    $("eConf").value = s.confidence || "mod";
    $("eSighters").checked = !!s.isSighters;
    $("eLabel").value = s.label || "";
    $("eUsed").value = Number.isFinite(s.shotsUsed) ? s.shotsUsed : "";
    $("eTotal").value = Number.isFinite(s.shotsTotal) ? s.shotsTotal : "";
    $("eVert").value = Number.isFinite(s.vert) ? s.vert : "";
    $("eMR").value = Number.isFinite(s.mr) ? s.mr : "";
    $("eSD").value = Number.isFinite(s.sd) ? s.sd : "";
    $("eFile").value = s.sourceFile || "";
    $("eNotes").value = s.notes || "";

    if (modal){
      modal.style.display = "flex";
      document.body.classList.add("modalOpen");
      // focus label for quick edits
      setTimeout(()=>{ try{$("eLabel")?.focus();}catch(e){} }, 0);
    }
  }

  function closeSessionModal(){
    const modal = $("sessModal");
    if (modal) modal.style.display = "none";
    document.body.classList.remove("modalOpen");
    _editingSessionId = null;
  }

  function validateSessionDraft(d){
    const problems = [];
    if (!d.date) problems.push("Date is required.");
    if (!d.label || !d.label.trim()) problems.push("Label is required.");
    if (!Number.isFinite(d.shotsUsed) || d.shotsUsed < 0) problems.push("Shots used must be a valid number.");
    if (!Number.isFinite(d.shotsTotal) || d.shotsTotal < 0) problems.push("Shots total must be a valid number.");
    if (d.shotsUsed > d.shotsTotal) problems.push("Shots used cannot exceed shots total.");
    if (!Number.isFinite(d.vert) || d.vert < 0) problems.push("Vert must be a valid number.");
    if (!Number.isFinite(d.mr) || d.mr < 0) problems.push("MR must be a valid number.");
    if (!Number.isFinite(d.sd) || d.sd < 0) problems.push("SD must be a valid number.");
    if (!["low","mod","high"].includes(d.confidence)) problems.push("Confidence must be Low/Moderate/High.");
    return problems;
  }

  function readSessionDraftFromModal(){
    return {
      date: ($("eDate")?.value || "").trim(),
      confidence: ($("eConf")?.value || "mod"),
      isSighters: !!$("eSighters")?.checked,
      label: ($("eLabel")?.value || "").trim(),
      shotsUsed: Number(($("eUsed")?.value || "").trim()),
      shotsTotal: Number(($("eTotal")?.value || "").trim()),
      vert: Number(($("eVert")?.value || "").trim()),
      mr: Number(($("eMR")?.value || "").trim()),
      sd: Number(($("eSD")?.value || "").trim()),
      sourceFile: ($("eFile")?.value || "").trim(),
      notes: ($("eNotes")?.value || "").trim()
    };
  }

  function saveSessionFromModal(){
    const sid = _editingSessionId;
    const s = sessionById(sid);
    if (!s) return;

    const d = readSessionDraftFromModal();
    const problems = validateSessionDraft(d);
    const err = $("sessModalErr");
    if (problems.length){
      if (err){
        err.style.display = "block";
        err.textContent = problems.join(" ");
      }
      return;
    }

    s.date = d.date;
    s.confidence = d.confidence;
    s.isSighters = d.isSighters;
    s.label = d.label;
    s.shotsUsed = d.shotsUsed;
    s.shotsTotal = d.shotsTotal;
    s.vert = d.vert;
    s.mr = d.mr;
    s.sd = d.sd;
    s.sourceFile = d.sourceFile;
    s.notes = d.notes;

    bumpRev();
    closeSessionModal();
    toast("Session updated.", "success");
    render();
  }

  async function deleteEditingSession(){
    const sid = _editingSessionId;
    if (!sid) return;
    const s = sessionById(sid);
    if (!s) return;

    const ok = await confirmDialog(
      `Delete session ${s.id}? This will remove it from this barrelâ€™s timeline and rankings.`,
      { title: "Delete session", okText: "Delete", cancelText: "Cancel" }
    );
    if (!ok) return;

    const idx = state.sessions.findIndex(x => x.id === sid);
    const removed = deepClone(s);

    state.sessions = state.sessions.filter(x => x.id !== sid);
    bumpRev();
    closeSessionModal();

    toast("Session deleted.", "success", "Deleted", 6000, {
      actionLabel: "Undo",
      onAction: () => {
        if (idx >= 0 && idx <= state.sessions.length) state.sessions.splice(idx, 0, removed);
        else state.sessions.push(removed);
        bumpRev();
        render();
      }
    });

    render();
  }

  function duplicateEditingSession(){
    const sid = _editingSessionId;
    if (!sid) return;
    const s = sessionById(sid);
    if (!s) return;

    const copy = JSON.parse(JSON.stringify(s));
    copy.id = "D" + Math.random().toString(36).slice(2,9).toUpperCase();
    copy.label = (copy.label ? (copy.label + " (copy)") : "Copy");
    state.sessions.push(copy);
    bumpRev();
    closeSessionModal();
    toast("Session duplicated.", "success");
    render();
  }

  function wireSessionModal(){
    $("btnSessClose")?.addEventListener("click", closeSessionModal);
    $("btnSessCancel")?.addEventListener("click", closeSessionModal);
    $("btnSessSave")?.addEventListener("click", saveSessionFromModal);
    $("btnSessDelete")?.addEventListener("click", deleteEditingSession);
    $("btnSessDuplicate")?.addEventListener("click", duplicateEditingSession);

    // click outside card closes
    $("sessModal")?.addEventListener("click", (e) => {
      if (e.target && e.target.id === "sessModal") closeSessionModal();
    });

    // Esc closes
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape"){
        const modal = $("sessModal");
        if (modal && modal.style.display === "flex") closeSessionModal();
      }
    });
  }

function wire(){
    // Phase 1â€“5 styles (small additive)
    const st = document.createElement("style");
    st.textContent = `
      .scoreCell{ cursor:pointer; text-decoration: underline dotted rgba(255,255,255,.25); text-underline-offset: 2px; }
      .scoreCell:hover{ text-decoration-color: rgba(255,255,255,.55); }
      .chip.impact{ font-weight:900; }
      .chip.impact.good{ border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.12); color: rgba(220,252,231,.95); }
      .chip.impact.neutral{ border-color: rgba(148,163,184,.28); background: rgba(148,163,184,.10); color: rgba(226,232,240,.92); }
      .chip.impact.bad{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); color: rgba(254,226,226,.95); }
      #guideOverlay{ display:none; }

      /* Phase 4: column visibility */
      .rankWrap{ overflow:auto; }
      .rankWrap.hide-rank [data-col="rank"], .rankWrap.hide-rank th[data-col="rank"],
      .rankWrap.hide-conf [data-col="conf"], .rankWrap.hide-conf th[data-col="conf"],
      .rankWrap.hide-vert [data-col="vert"], .rankWrap.hide-vert th[data-col="vert"],
      .rankWrap.hide-mr [data-col="mr"], .rankWrap.hide-mr th[data-col="mr"],
      .rankWrap.hide-sd [data-col="sd"], .rankWrap.hide-sd th[data-col="sd"],
      .rankWrap.hide-life [data-col="life"], .rankWrap.hide-life th[data-col="life"],
      .rankWrap.hide-trend [data-col="trend"], .rankWrap.hide-trend th[data-col="trend"],
      .rankWrap.hide-last [data-col="last"], .rankWrap.hide-last th[data-col="last"]{ display:none !important; }


/* Trend popover (click Trend pill) */
.pillTrend{ cursor:pointer; }
.pillTrend:focus{ outline: 2px solid rgba(148,163,184,.45); outline-offset: 2px; }

#trendPop{ position:fixed; inset:0; display:none; z-index: 99999; }
#trendPop.show{ display:block; }
#trendPop .trendCard{
  position:fixed;
  width: 340px;
  max-width: calc(100vw - 24px);
  border-radius: 18px;
  border:1px solid rgba(148,163,184,.24);
  background: rgba(2,6,23,.94);
  box-shadow: 0 24px 80px rgba(0,0,0,.55);
  padding: 14px 14px 12px;
  color: rgba(226,232,240,.96);
}
#trendPop .trendHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
#trendPop .trendTitle{ font-size: 22px; font-weight: 900; letter-spacing: .2px; }
#trendPop .trendClose{
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  color: rgba(226,232,240,.92);
  border-radius: 12px;
  height: 34px;
  width: 34px;
  display:grid;
  place-items:center;
  cursor:pointer;
}
#trendPop .trendClose:hover{ background: rgba(148,163,184,.12); }

#trendPop .trendRow{ display:flex; align-items:center; gap:12px; }
#trendPop .trendIcon{
  width: 44px; height: 44px;
  border-radius: 14px;
  border:1px solid rgba(148,163,184,.22);
  background: rgba(148,163,184,.08);
  display:grid; place-items:center;
  font-weight: 900;
}
#trendPop .trendIcon.good{ border-color: rgba(34,197,94,.32); background: rgba(34,197,94,.10); color: rgba(220,252,231,.95); }
#trendPop .trendIcon.bad{  border-color: rgba(239,68,68,.32); background: rgba(239,68,68,.10); color: rgba(254,226,226,.95); }
#trendPop .trendIcon.neutral{ border-color: rgba(148,163,184,.26); background: rgba(148,163,184,.08); color: rgba(226,232,240,.92); }

#trendPop .trendSpark{ width: 240px; height: 56px; display:block; }
#trendPop .sparkPath{ fill:none; stroke: rgba(148,163,184,.85); stroke-width:3; stroke-linecap:round; }
#trendPop .sparkDot{ fill: rgba(226,232,240,.92); }
#trendPop .sparkPath.good{ stroke: rgba(34,197,94,.9); }
#trendPop .sparkPath.bad{  stroke: rgba(239,68,68,.9); }
#trendPop .sparkPath.neutral{ stroke: rgba(148,163,184,.85); }
#trendPop .trendText{ margin-top: 10px; color: var(--muted); font-size: 13px; line-height: 1.35; }

/* Columns modal */
      #colsOverlay{ display:none; }
      .colsGrid{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
      .colsGrid label{ display:flex; gap:10px; align-items:center; padding:10px; border-radius:12px;
        border:1px solid rgba(148,163,184,.22); background: rgba(148,163,184,.06); }
      .colsGrid input{ transform: translateY(1px); }
      .colsHint{ color: var(--muted); font-size: 12px; margin-top: 8px; }
`;
    document.head.appendChild(st);

    // Trend details: click the Trend pill to open the trend popover.

    wireSessionModal();
    loadUiPrefs();
    ensureUi();
    const elSelWindow = $("selWindow");
    if (elSelWindow) elSelWindow.addEventListener("change", (e) => {
      if (state.rankLocked){
        e.target.value = String(state.lockedWindowRounds ?? state.windowRounds);
        return;
      }
      state.windowRounds = parseInt(e.target.value, 10);
      render();
    });
const elSelMinConf = $("selMinConf");
    if (elSelMinConf) elSelMinConf.addEventListener("change", (e) => {
      state.minConf = e.target.value;
      render();
    });
const elChkSighters = $("chkSighters");
    if (elChkSighters) elChkSighters.addEventListener("change", (e) => {
      state.showSighters = !!e.target.checked;
      render();
    });
// Phase 1: search / filter / sort
    if (!state.ui) state.ui = { search:"", filter:"all", sort:"rank" };

    const inpSearch = $("inpSearch");
    if (inpSearch){
      inpSearch.value = state.ui.search || "";
      inpSearch.addEventListener("input", (e) => {
        state.ui.search = String(e.target.value || "");
        renderRanking();
      });
      inpSearch.addEventListener("keydown", (e) => {
        if (e.key === "Escape"){
          e.preventDefault();
          e.target.value = "";
          state.ui.search = "";
          renderRanking();
        }
      });
    }

    const selFilter = $("selFilter");
    if (selFilter){
      selFilter.value = state.ui.filter || "all";
      selFilter.addEventListener("change", (e) => {
        state.ui.filter = String(e.target.value || "all");
        renderRanking();
      });
    }

    const selSort = $("selSort");
    if (selSort){
      selSort.value = state.ui.sort || "rank";
      selSort.addEventListener("change", (e) => {
        state.ui.sort = String(e.target.value || "rank");
        renderRanking();
      });
    }

    // Phase 4: Layout + Columns controls
    const selLayout = $("selLayout");
    if (selLayout){
      selLayout.value = state.ui.layout || "Default";
      selLayout.addEventListener("change", (e) => {
        const v = String(e.target.value || "Default");
        if (v !== "Custom") applyLayout(v);
        else { ensureUi(); state.ui.layout = "Custom"; saveUiPrefs(); }
        render();
      });
    }

    const colsOverlay = $("colsOverlay");
    const openCols = () => {
      if (!colsOverlay) return;
      ensureUi();
      // hydrate grid
      const grid = $("colsGrid");
      if (grid){
        const v = state.ui.colVis || defaultColVis();
        const keys = ["rank","conf","vert","mr","sd","life","trend","last"];
        grid.innerHTML = keys.map(k => {
          const checked = !!v[k];
          const label = COL_META[k]?.label || k;
          return `<label><input type="checkbox" data-colkey="${k}" ${checked ? "checked" : ""} /> <div><b>${escapeHTML(label)}</b><div style="color:var(--muted);font-size:12px;">Toggle ${escapeHTML(label)}</div></div></label>`;
        }).join("");
        grid.querySelectorAll('input[type="checkbox"][data-colkey]').forEach(cb => {
          cb.addEventListener("change", () => {
            const key = cb.getAttribute("data-colkey");
            if (!key) return;
            ensureUi();
            state.ui.colVis[key] = !!cb.checked;
            state.ui.layout = "Custom";
            saveUiPrefs();
            applyColumnVisibility();
          });
        });
      }
      document.body.classList.add("modalOpen");
      colsOverlay.style.display = "flex";
      colsOverlay.setAttribute("aria-hidden","false");
      applyColumnVisibility();
      // keep layout select in sync
      if (selLayout) selLayout.value = state.ui.layout || "Custom";
    };
    const closeCols = () => {
      if (!colsOverlay) return;
      document.body.classList.remove("modalOpen");
      colsOverlay.style.display = "none";
      colsOverlay.setAttribute("aria-hidden","true");
      saveUiPrefs();
      render();
    };

    $("btnColumns")?.addEventListener("click", openCols);
    $("btnColsClose")?.addEventListener("click", closeCols);
    $("btnColsOk")?.addEventListener("click", closeCols);
    colsOverlay?.addEventListener("click", (e) => { if (e.target === colsOverlay) closeCols(); });
    document.addEventListener("keydown", (ev) => { if (ev.key === "Escape") closeCols(); });

    $("btnColsAll")?.addEventListener("click", () => {
      ensureUi();
      state.ui.colVis = defaultColVis();
      state.ui.layout = "Custom";
      saveUiPrefs();
      openCols();
    });
    $("btnColsCompact")?.addEventListener("click", () => {
      applyLayout("Compact");
      if (selLayout) selLayout.value = "Compact";
      openCols();
    });
    $("btnColsReset")?.addEventListener("click", () => {
      applyLayout("Default");
      if (selLayout) selLayout.value = "Default";
      openCols();
    });




        $("btnClear").addEventListener("click", async () => {
          const snap = snapshotAppState();
          const ok = await confirmDialog(
            "Clear ALL barrels + sessions? (You can undo right after.)",
            { title: "Clear all data", okText: "Clear", cancelText: "Cancel" }
          );
          if (!ok) return;

          clearAll();
          render();

          toast("All data cleared.", "warn", "Cleared", 6500, {
            actionLabel: "Undo",
            onAction: () => restoreAppState(snap)
          });
        });

        $("btnResetView")?.addEventListener("click", resetView);
        $("btnQuickHelp")?.addEventListener("click", () => $("btnGuide")?.click?.());

    // Phase 1: score breakdown popover
    const scorePop = $("scorePop");
    const scorePopBody = $("scorePopBody");
    const closeScorePop = () => { if (scorePop) scorePop.style.display = "none"; };
    $("btnScorePopClose")?.addEventListener("click", closeScorePop);
    document.addEventListener("keydown", (ev) => { if (ev.key === "Escape") { closeScorePop(); } });

    // Delegate click from ranking table to show score breakdown
    $("rankBody").addEventListener("click", (ev) => {
      const el = ev.target.closest?.(".scoreCell");
      if (!el) return;
      ev.stopPropagation();
      const bid = el.getAttribute("data-barrel");
      const breakdown = scoreBreakdown(bid);
      if (!breakdown) return;
      scorePopBody.innerHTML = breakdown.html;
      // position popover near click, but keep on-screen
      const r = el.getBoundingClientRect();
      const w = 360, h = 260;
      let left = Math.min(window.innerWidth - w - 12, Math.max(12, r.left));
      let top = Math.min(window.innerHeight - h - 12, Math.max(12, r.bottom + 10));
      scorePop.style.position = "fixed";
      scorePop.style.left = left + "px";
      scorePop.style.top = top + "px";
      scorePop.style.right = "auto";
      scorePop.style.display = "block";
    });

    // Hide score popover on outside click
    document.addEventListener("click", (ev) => {
      if (!scorePop || scorePop.style.display === "none") return;
      const inside = ev.target.closest?.("#scorePop") || ev.target.closest?.(".scoreCell");
      if (!inside) closeScorePop();
    });

    // Phase 4: match-day scope lock
    $("btnLockScope")?.addEventListener("click", () => {
      state.rankLocked = !state.rankLocked;
      if (state.rankLocked){
        state.lockedWindowRounds = state.windowRounds;
        state.lockedAtISO = new Date().toISOString();
      } else {
        state.lockedWindowRounds = null;
        state.lockedAtISO = null;
      }
      renderLabels();
      renderRanking();
    });

    // Phase 5: guide modal
    const guide = $("guideOverlay");
    const openGuide = () => { if (!guide) return; document.body.classList.add("modalOpen"); guide.style.display = "flex"; guide.setAttribute("aria-hidden","false"); };
    const closeGuide = () => { if (!guide) return; document.body.classList.remove("modalOpen"); guide.style.display = "none"; guide.setAttribute("aria-hidden","true"); };
    $("btnGuide")?.addEventListener("click", openGuide);
    $("btnGuideClose")?.addEventListener("click", closeGuide);
    $("btnGuideOk")?.addEventListener("click", closeGuide);
    $("btnSupportBundle")?.addEventListener("click", () => {
      const bundle = buildSupportBundle();
      const ymd = (bundle.created_at || new Date().toISOString()).slice(0,10);
      downloadText(`BarrelTracker_support_${ymd}.json`, JSON.stringify(bundle, null, 2), "application/json");
      toast("Support bundle exported.", "ok");
    });

    guide?.addEventListener("click", (e) => { if (e.target === guide) closeGuide(); });
    document.addEventListener("keydown", (ev) => { if (ev.key === "Escape") closeGuide(); });

    $("btnImportGlobal").addEventListener("click", () => {
      if (!state.selectedBarrelId){
        toast("Select a barrel row first, then import.", "warn");
        return;
      }
      openImport(state.selectedBarrelId);
    });


    $("btnExport").addEventListener("click", () => {
      // Export everything (barrels + sessions) as JSON
      const payload = buildExportPayload();
      const ymd = payload.created_at.slice(0,10);
      downloadText(`BarrelTracker_export_${ymd}.json`, JSON.stringify(payload, null, 2), "application/json");
    });


    $("btnImportJSON").addEventListener("click", () => {
      $("fileImportJSON").value = "";
      $("fileImportJSON").click();
    });

    $("fileImportJSON").addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      try{
        const text = await f.text();
        const payloadRaw = JSON.parse(text);
        const payload = migrateExportPayload(payloadRaw);

        // Basic validation (post-migration)
        const ok = payload && payload.app === "BarrelTracker" && payload.state &&
          Array.isArray(payload.state.barrels) && Array.isArray(payload.state.sessions);
        if (!ok){
          toast("That JSON doesn't look like a BarrelTracker export.", "error");
          return;
        }

        const replace = await confirmDialog(
          "Import JSON:\n\nOK = REPLACE current barrels + sessions\nCancel = MERGE (keep existing, add/overwrite by id)",
          { title: "Import JSON", okText: "Replace", cancelText: "Merge" }
        );
        if (replace){
          state.barrels = payload.state.barrels || [];
          state.sessions = payload.state.sessions || [];
        } else {
          // Merge barrels by id
          const bMap = new Map((state.barrels||[]).map(b => [b.id, b]));
          for (const b of (payload.state.barrels||[])){
            if (!b || !b.id) continue;
            bMap.set(b.id, b);
          }
          state.barrels = [...bMap.values()];

          // Merge sessions by id (import overwrites same id)
          const sMap = new Map((state.sessions||[]).map(s => [s.id, s]));
          for (const s of (payload.state.sessions||[])){
            if (!s || !s.id) continue;
            sMap.set(s.id, s);
          }
          state.sessions = [...sMap.values()];
        }

        // Restore settings if present
        const set = payload.state.settings || {};
        if (set.windowRounds) state.windowRounds = set.windowRounds;
        if (set.minConf != null || set.minConfidence != null) state.minConf = (set.minConf != null ? set.minConf : set.minConfidence);
        if (typeof set.showSighters === "boolean") state.showSighters = set.showSighters;

        // Ensure we have a selected barrel
        if (!state.selectedBarrelId || !state.barrels.find(b => b.id === state.selectedBarrelId)){
          state.selectedBarrelId = (state.barrels[0] && state.barrels[0].id) ? state.barrels[0].id : null;
        }

        state.detailMode = "timeline";
                normalizeState();

        bumpRev();
        toast(replace ? "JSON imported (replaced current data)." : "JSON imported (merged with current data).", "success");
        render();
      }catch(err){
        toast("Import failed: " + String(err && err.message ? err.message : err), "error");
      }
    });


$("btnAddBarrel").addEventListener("click", () => {
      const pop = $("barrelPop");
      pop.style.display = (pop.style.display === "block") ? "none" : "block";
      $("inpBarrelId").focus();
    });

    $("btnBarrelCancel").addEventListener("click", () => {
      $("barrelPop").style.display = "none";
      $("inpBarrelId").value = "";
      $("inpBarrelTwist").value = "";
      $("inpBarrelTwistCustom").value = "";
      $("inpBarrelTwistCustom").style.display = "none";
      if ($("inpBarrelStartRounds")) $("inpBarrelStartRounds").value = "";
    });

    $("inpBarrelTwist").addEventListener("change", (e) => {
      const v = e.target.value;
      const cust = $("inpBarrelTwistCustom");
      if (!cust) return;
      cust.style.display = (v === "custom") ? "" : "none";
      if (v !== "custom") cust.value = "";
    });


    $("btnBarrelSave").addEventListener("click", () => {
      const bid = ($("inpBarrelId").value || "").trim();
      if (!bid){
        alert("Enter a barrel ID (e.g., B6).");
        return;
      }
      const twistSel = $("inpBarrelTwist").value || "";
      const twist = (twistSel === "custom") ? (String($("inpBarrelTwistCustom").value || "").trim()) : twistSel;
      const srRaw = String(($("inpBarrelStartRounds") && $("inpBarrelStartRounds").value) || "").trim();
      const startRounds = Math.max(0, Math.floor(Number(srRaw || 0)));

      const b = ensureBarrel(bid);
      if (twist) b.twist = twist;
      b.startRounds = Number.isFinite(startRounds) ? startRounds : 0;
      state.selectedBarrelId = b.id;
      state.detailMode = "timeline";
      state.draft = null;
      $("barrelPop").style.display = "none";
      $("inpBarrelId").value = "";
      $("inpBarrelTwist").value = "";
      $("inpBarrelTwistCustom").value = "";
      $("inpBarrelTwistCustom").style.display = "none";
      if ($("inpBarrelStartRounds")) $("inpBarrelStartRounds").value = "";
      render();
    });

// Trend popover (click Trend mini)
const rankBody = $("rankBody");
if (rankBody){
  rankBody.addEventListener("click", (e) => {
    const t = (e.target && e.target.nodeType===3) ? e.target.parentElement : e.target;
    const btn = t?.closest?.(".trendMini");
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    const bid = btn.getAttribute("data-trend");
    if (!bid) return;
    openTrendPopover(bid, btn);
  });
}
window.addEventListener("scroll", () => { if (_trendPopOpen) hideTrendPopover(); }, { passive:true, capture:true });
window.addEventListener("resize", () => { if (_trendPopOpen) hideTrendPopover(); }, { passive:true });
document.addEventListener("keydown", (e) => { if (e.key === "Escape") hideTrendPopover(); });


    // Command palette (Ctrl/Cmd+K) + global shortcuts
    initCmdk();

    document.addEventListener("keydown", (e) => {
      try{
        const ov = $("cmdkOverlay");
        const cmdkOpen = !!(ov && ov.style.display === "flex");
        const ctrl = e.ctrlKey || e.metaKey;
        const key = (e.key || "");

        // Open palette
        if (ctrl && key.toLowerCase() === "k"){
          e.preventDefault();
          openCmdk();
          return;
        }

        // If palette open, Esc closes (input handles arrows/enter)
        if (cmdkOpen && key === "Escape"){
          e.preventDefault();
          closeCmdk();
          return;
        }

        // Don't hijack typing
        if (isTypingContext()) return;

        // Quick actions
        if (key === "/"){
          e.preventDefault();
          $("inpSearch")?.focus?.();
          return;
        }
        if (key === "?"){
          e.preventDefault();
          $("btnGuide")?.click?.();
          return;
        }
        if (key.toLowerCase() === "l"){
          e.preventDefault();
          $("btnLockScope")?.click?.();
          return;
        }
        if (key.toLowerCase() === "i"){
          e.preventDefault();
          openImport(state.selectedBarrelId);
          return;
        }
        if (key.toLowerCase() === "m"){
          e.preventDefault();
          openAddSession(state.selectedBarrelId);
          return;
        }
      }catch{}
    }, true);

}


  // Hover tooltips (offline-safe; avoids relying on browser native tooltip quirks)
  function initHoverTooltips(){
    // Convert any leftover title= tooltips into data-tip and remove native titles
    purgeNativeTooltips(document);

    const existing = document.getElementById("uiTooltip");
    const tt = existing || document.createElement("div");
    if (!existing){
      tt.id = "uiTooltip";
      tt.className = "uiTooltip";
      document.body.appendChild(tt);
    }else{
      try{ tt.classList.add("uiTooltip"); }catch{}
    }

    let active = null;

    function hide(){
      active = null;
      tt.style.display = "none";
    }

    function show(el, msg){
      active = el;
      tt.innerHTML = msg;
      tt.style.display = "block";
    }

    function position(ev){
      if (!active || tt.style.display === "none") return;
      let x = (ev && ev.clientX != null) ? ev.clientX : (active.getBoundingClientRect().left + 12);
      let y = (ev && ev.clientY != null) ? ev.clientY : (active.getBoundingClientRect().top + 12);
      x += 14; y += 14;

      const pad = 10;
      const w = tt.offsetWidth || 0;
      const h = tt.offsetHeight || 0;
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      if (x + w + pad > vw) x = Math.max(pad, vw - w - pad);
      if (y + h + pad > vh) y = Math.max(pad, vh - h - pad);

      tt.style.left = x + "px";
      tt.style.top  = y + "px";
    }

    // Support both data-tip and title (we migrate title->data-tip, but this is extra safety)
    function findTipTarget(node){
      const el = node?.closest?.("[data-tip],[title]");
      if (!el) return null;
      const msg = (el.getAttribute("data-tip") || el.getAttribute("title") || "").trim();
      if (!msg) return null;
      // If it's coming from title, migrate immediately so native tooltip doesn't show later
      if (!el.getAttribute("data-tip") && el.getAttribute("title")) {
        el.setAttribute("data-tip", msg);
        el.removeAttribute("title");
      }
      return el;
    }

    document.addEventListener("mouseover", (ev) => {
      const el = findTipTarget(ev.target);
      if (!el) return;
      const msg = el.getAttribute("data-tip");
      if (!msg) return;
      show(el, msg);
      position(ev);
    }, true);

    document.addEventListener("mousemove", (ev) => {
      if (!active) return;
      position(ev);
    }, true);

    document.addEventListener("mouseout", (ev) => {
      if (!active) return;
      const from = ev.target?.closest?.("[data-tip],[title]");
      if (!from || from !== active) return;
      const to = ev.relatedTarget?.closest?.("[data-tip],[title]");
      if (to === active) return;
      hide();
    }, true);

    // If the UI changes under you, just hide to avoid "dangling" tooltips
    window.addEventListener("scroll", hide, { passive:true, capture:true });
    window.addEventListener("resize", hide, { passive:true });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape") hide(); });

    // Keep tooltips working even if later renders inject new title="" attributes
    try{
      const mo = new MutationObserver((muts) => {
        for (const m of muts){
          if (m.type !== "childList") continue;
          m.addedNodes.forEach(n => {
            if (!(n instanceof Element)) return;
            // Fast-path: if the node (or its subtree) contains title attributes, migrate them.
            if (n.matches?.("[title]") || n.querySelector?.("[title]")) purgeNativeTooltips(n);
          });
        }
      });
      mo.observe(document.body, { childList:true, subtree:true });
    }catch{}
  }


  document.addEventListener("DOMContentLoaded", async () => {
    wire();
    initHoverTooltips();
    await maybeOfferRestoreAutosave();
    render();
  });
})();
</script>

  <!-- Session Edit Modal -->

  <!-- Command palette -->
  <div class="cmdkOverlay" id="cmdkOverlay" role="dialog" aria-modal="true" aria-label="Command palette">
    <div class="cmdkCard">
      <div class="cmdkTop">
        <input class="cmdkInput" id="cmdkInput" placeholder="Type a commandâ€¦ (Esc to close)" autocomplete="off">
        <span class="cmdkKbd">Esc</span>
      </div>
      <div class="cmdkList" id="cmdkList" role="listbox" aria-label="Commands"></div>
    </div>
  </div>

<div class="modalOverlay" id="sessModal">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="sessModalTitle">
      <div class="modalHead">
        <div>
          <h3 id="sessModalTitle">Edit session</h3>
          <div class="small" id="sessModalSub" style="margin-top:6px;color:var(--muted);">â€”</div>
        </div>
        <button class="btn sm" id="btnSessClose">Close</button>
      </div>
      <div class="modalBody">
        <div class="kpis" style="grid-template-columns:repeat(3,minmax(0,1fr));">
          <div class="kpi">
            <div class="lbl">Date</div>
            <input id="eDate" type="date" class="select" style="width:100%;margin-top:6px;">
          </div>
          <div class="kpi">
            <div class="lbl">Confidence</div>
            <select id="eConf" class="select" style="width:100%;margin-top:6px;">
              <option value="low">Low</option>
              <option value="mod">Moderate</option>
              <option value="high">High</option>
            </select>
          </div>
          <div class="kpi">
            <div class="lbl">Type</div>
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px;">
              <label class="toggle" style="padding:6px 10px;"><input id="eSighters" type="checkbox"> Sighters session</label>
            </div>
            <div class="mini" style="margin-top:6px;color:var(--muted);">Unchecked = record shots.</div>
          </div>
        </div>

        <div class="kpi" style="margin-top:12px;">
          <div class="lbl">Label (shows in timeline)</div>
          <input id="eLabel" class="select" style="width:100%;margin-top:6px;" placeholder="e.g., Oct 11 2025 â€” M2 R1 TT9-218 â€” #218 (T9-218)">
        </div>

        <div class="kpis" style="margin-top:12px;">
          <div class="kpi">
            <div class="lbl">Shots used</div>
            <input id="eUsed" type="number" min="0" step="1" class="select" style="width:100%;margin-top:6px;">
          </div>
          <div class="kpi">
            <div class="lbl">Shots total</div>
            <input id="eTotal" type="number" min="0" step="1" class="select" style="width:100%;margin-top:6px;">
          </div>
          <div class="kpi">
            <div class="lbl">Source file</div>
            <input id="eFile" class="select" style="width:100%;margin-top:6px;" placeholder="e.g., Rifle_Bullet_2025-10-11_08-19-43.xls">
          </div>
        </div>

        <div class="kpis" style="margin-top:12px;">
          <div class="kpi">
            <div class="lbl">Vert (MOA)</div>
            <input id="eVert" type="number" step="0.01" class="select" style="width:100%;margin-top:6px;">
          </div>
          <div class="kpi">
            <div class="lbl">MR (MOA)</div>
            <input id="eMR" type="number" step="0.01" class="select" style="width:100%;margin-top:6px;">
          </div>
          <div class="kpi">
            <div class="lbl">SD (fps)</div>
            <input id="eSD" type="number" step="0.1" class="select" style="width:100%;margin-top:6px;">
          </div>
        </div>

        <div class="kpi" style="margin-top:12px;">
          <div class="lbl">Notes</div>
          <textarea id="eNotes" class="select" style="width:100%;margin-top:6px;height:90px;resize:vertical;" placeholder="Anything noteworthyâ€¦"></textarea>
        </div>

        <div class="pill warn" id="sessModalErr" style="display:none;margin-top:12px;"></div>
      </div>
      <div class="modalFoot">
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="btn sm" id="btnSessDuplicate">Duplicate</button>
          <button class="btn sm danger" id="btnSessDelete">Delete</button>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="btn sm" id="btnSessCancel">Cancel</button>
          <button class="btn sm primary" id="btnSessSave">Save changes</button>
        </div>
      </div>
    </div>
  </div>





<div id="uiTooltip" class="uiTooltip" style="display: none;"></div><div id="confirmOverlay" class="confirmOverlay" style="display: none;">
      <div class="confirmCard" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
        <div class="confirmTitle" id="confirmTitle">Restore autosave?</div>
        <div class="confirmMsg" id="confirmMsg">Restore your last autosave from 1/4/2026, 9:14:14 PM?

Barrels: 6
Sessions: 9

(You can also ignore this and continue.)</div>
        <div class="confirmActions">
          <button class="btn sm" id="btnConfirmCancel">Not now</button>
          <button class="btn sm primary" id="btnConfirmOK">Restore</button>
        </div>
      </div>
    </div><div id="twc-ssr-ioo-phe" style="position: fixed; top: 0px; left: 0px; width: 100%; height: 100%; z-index: 10000; pointer-events: none;"><template shadowrootmode="open"><div>
        <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Lato', sans-serif;
}

button {
    padding: 0;
    border: none;
    font: inherit;
    color: inherit;
    background-color: transparent;
    cursor: pointer;
}

#shortcut-selected,
#shortcut-visible {
    position: absolute;
    top: 15px;
    right: 335px;
}

.tooltip{
    display: flex;
    flex-direction: column;
    position: relative;
    color: #ffffff;
    gap: 16px;
    width: 365px;
    padding: 25px;
    background-color: #212121;
    border-radius: 10px;
    box-shadow: 0px 0px 20px 0px rgba(185, 185, 185, 0.6);
    z-index: 1000;
    pointer-events: auto;
}

.tooltip__header{
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.tooltip__icon{
    height: 20px;
    width: 20px;
}

.tooltip__title{
    display: flex;
    align-items: center;
    gap: 8px;
}

.tooltip__title h3{
    font-size: 18px;
    font-weight: 600;
}

.tooltip__close{
    padding: 0;
    margin: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.tooltip__content{
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.tooltip__subtitle{
    font-size: 14px;
    font-weight: 400;
}

.tooltip__stats{
    font-size: 12px;
    font-weight: 400;
}

.tooltip__actions{
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.tooltip__settings{
    border: 1px solid #212121;
    padding: 6px 0;
    border-radius: 5px;
    color: #D5D5D5;
    font-size: 14px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding-left: 5px;
}

.tooltip__settings:hover{
    border: 1px solid #06DFC9;
    color: #ffffff;
}

.tooltip__settings:hover img,
.tooltip__settings-text:hover{
    filter: brightness(0) saturate(100%) invert(100%) sepia(0%) saturate(7500%) hue-rotate(56deg) brightness(97%) contrast(107%);
}

.tooltip__confirm{
    background: #06DFC9;
    border: 1px solid #06DFC9;
    padding: 6px 0;
    border-radius: 5px;
    color: #212121;
    width: 100%;
    font-size: 14px;
    font-weight: 700;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
}

.tooltip__confirm:hover{
    border: 1px solid #05AD9C;
    background: #05AD9C;
}

.tooltip__confirm:active{
    background: #05AD9C;
    color: #ffffff;
}

.tooltip--arrow-top::before{
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 15px solid #212121;
}

.tooltip--arrow-left::before{
    content: '';
    position: absolute;
    top: 50%;
    left: -10px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-top: 15px solid transparent;
    border-bottom: 15px solid transparent;
    border-right: 15px solid #212121;
}

.tooltip--arrow-right::after{
    content: '';
    position: absolute;
    top: 50%;
    right: -10px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-top: 15px solid transparent;
    border-bottom: 15px solid transparent;
    border-left: 15px solid #212121;
}

.hidden{
    display: none;
}</style>
        
            <div id="shortcut-selected" class="tooltip tooltip--arrow-top hidden">
                <div class="tooltip__header">
                    <div class="tooltip__title">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/badge-emblem.svg" alt="badge-emblem icon" class="tooltip__icon"><img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/selected.svg" alt="selected icon" class="tooltip__icon">
                        <h3 class="tooltip__title">Alt + Shift + S</h3>
                    </div>
                    <button class="tooltip__close">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/close.svg" alt="close-icon">
                    </button>
                </div>
    
                <div class="tooltip__content">
                    <p class="tooltip__subtitle">Shortcut for <strong>Selected Area</strong> screenshot</p>
                    <p class="tooltip__stats">57% of SimpleSnap users capture with shortcut</p> 
                </div>
    
                
        <div class="tooltip__actions">
            <button class="tooltip__settings">
                <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/settings.svg" alt="settings-icon">
                <p class="tooltip__settings-text">Settings</p>
            </button>
            <button class="tooltip__confirm">Got it</button>
        </div>
            </div>
        
            <div id="shortcut-visible" class="tooltip tooltip--arrow-top hidden">
                <div class="tooltip__header">
                    <div class="tooltip__title">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/badge-emblem.svg" alt="badge-emblem icon" class="tooltip__icon"><img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/viewport-route.svg" alt="viewport-route icon" class="tooltip__icon">
                        <h3 class="tooltip__title">Alt + Shift + V</h3>
                    </div>
                    <button class="tooltip__close">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/close.svg" alt="close-icon">
                    </button>
                </div>
    
                <div class="tooltip__content">
                    <p class="tooltip__subtitle">Shortcut for <strong>Visible Area</strong> screenshot</p>
                    <p class="tooltip__stats">58% of SimpleSnap users capture with shortcut</p> 
                </div>
    
                
        <div class="tooltip__actions">
            <button class="tooltip__settings">
                <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/settings.svg" alt="settings-icon">
                <p class="tooltip__settings-text">Settings</p>
            </button>
            <button class="tooltip__confirm">Got it</button>
        </div>
            </div>
        
            <div id="lines" class="tooltip tooltip--arrow-left hidden">
                <div class="tooltip__header">
                    <div class="tooltip__title">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/ui.svg" alt="ui icon" class="tooltip__icon">
                        <h3 class="tooltip__title">Lines and Arrows</h3>
                    </div>
                    <button class="tooltip__close">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/close.svg" alt="close-icon">
                    </button>
                </div>
    
                <div class="tooltip__content">
                    <p class="tooltip__subtitle">Draw arrows and lines - straight or freehand, select color and line width here.</p>
                    <p class="tooltip__stats">Most users start their edits here.</p> 
                </div>
    
                
            </div>
        
            <div id="crop" class="tooltip tooltip--arrow-left hidden">
                <div class="tooltip__header">
                    <div class="tooltip__title">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/selected.svg" alt="selected icon" class="tooltip__icon">
                        <h3 class="tooltip__title">Crop</h3>
                    </div>
                    <button class="tooltip__close">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/close.svg" alt="close-icon">
                    </button>
                </div>
    
                <div class="tooltip__content">
                    <p class="tooltip__subtitle">You can trim your screenshot to focus on a specific area â€” just select the zone you want to keep, and the rest will be cropped out</p>
                    <p class="tooltip__stats">A useful feature many users overlook.</p> 
                </div>
    
                
            </div>
        
            <div id="undo" class="tooltip tooltip--arrow-right hidden">
                <div class="tooltip__header">
                    <div class="tooltip__title">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/undo-arrow.svg" alt="undo-arrow icon" class="tooltip__icon">
                        <h3 class="tooltip__title">Undo anytime</h3>
                    </div>
                    <button class="tooltip__close">
                        <img src="chrome-extension://nbljjljaoanknannhlonmaknhckcoldi/resources/graphics/close.svg" alt="close-icon">
                    </button>
                </div>
    
                <div class="tooltip__content">
                    <p class="tooltip__subtitle">Cancel edits and return to the previous appearance of screenshot.</p>
                    <p class="tooltip__stats">Right menu allows you to manage history of changes.</p> 
                </div>
    
                
            </div>
        
    </div></template></div><div id="capture-shell-npg1ku" data-snapoverlay="true" style="display: none;"><template shadowrootmode="open"><style>
    .captureShadeLayer {
        position: fixed; top: 0; width: 100%; left: 0; background: rgba(255, 255, 255, 0.22); height: 100%; cursor: crosshair; z-index: 2147483647;
    }
    .captureSelectionFrame {
        cursor: crosshair; z-index: 2147483647; border: 3px dashed #06DFC9; position: fixed; background-color: rgba(38, 37, 37, 0.69);
    }</style></template></div><div id="toastHost" class="toastHost" aria-live="polite"></div></body></html>
